<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>gin框架使用案例 | 流浪地球</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.ico">
    <meta name="description" content="纵然出走时未曾想要流浪半生，归来时早已发现少年不再">
    
    <link rel="preload" href="/assets/css/0.styles.7b36eabc.css" as="style"><link rel="preload" href="/assets/js/app.2cd84a3f.js" as="script"><link rel="preload" href="/assets/js/2.63c13255.js" as="script"><link rel="preload" href="/assets/js/21.11dd81d7.js" as="script"><link rel="prefetch" href="/assets/js/10.79ce38a9.js"><link rel="prefetch" href="/assets/js/11.b1d01830.js"><link rel="prefetch" href="/assets/js/12.8736c32f.js"><link rel="prefetch" href="/assets/js/13.ebee3709.js"><link rel="prefetch" href="/assets/js/14.2b0d4a27.js"><link rel="prefetch" href="/assets/js/15.e1d296a3.js"><link rel="prefetch" href="/assets/js/16.380d3c5e.js"><link rel="prefetch" href="/assets/js/17.746ecd1f.js"><link rel="prefetch" href="/assets/js/18.753f8f5a.js"><link rel="prefetch" href="/assets/js/19.9e16d87a.js"><link rel="prefetch" href="/assets/js/20.54b076df.js"><link rel="prefetch" href="/assets/js/22.29cdb2fb.js"><link rel="prefetch" href="/assets/js/23.fd2fe5c2.js"><link rel="prefetch" href="/assets/js/24.ca7d6a70.js"><link rel="prefetch" href="/assets/js/25.0564d66c.js"><link rel="prefetch" href="/assets/js/26.ad480a02.js"><link rel="prefetch" href="/assets/js/27.4c43d411.js"><link rel="prefetch" href="/assets/js/28.e66385b0.js"><link rel="prefetch" href="/assets/js/29.ae4baeca.js"><link rel="prefetch" href="/assets/js/3.55d44e04.js"><link rel="prefetch" href="/assets/js/30.ba670f02.js"><link rel="prefetch" href="/assets/js/31.f3f42409.js"><link rel="prefetch" href="/assets/js/32.5d600afc.js"><link rel="prefetch" href="/assets/js/33.40a2a336.js"><link rel="prefetch" href="/assets/js/34.2a621ea3.js"><link rel="prefetch" href="/assets/js/35.56b8ae56.js"><link rel="prefetch" href="/assets/js/36.9e35ae04.js"><link rel="prefetch" href="/assets/js/37.78bb6a4a.js"><link rel="prefetch" href="/assets/js/38.4955006a.js"><link rel="prefetch" href="/assets/js/39.9ae6e79e.js"><link rel="prefetch" href="/assets/js/4.13c31685.js"><link rel="prefetch" href="/assets/js/40.b516ee81.js"><link rel="prefetch" href="/assets/js/41.6d6a113f.js"><link rel="prefetch" href="/assets/js/42.3b5d7847.js"><link rel="prefetch" href="/assets/js/43.41821ddc.js"><link rel="prefetch" href="/assets/js/44.bb04bcbc.js"><link rel="prefetch" href="/assets/js/45.46e8e459.js"><link rel="prefetch" href="/assets/js/46.9de03981.js"><link rel="prefetch" href="/assets/js/47.aea7ab35.js"><link rel="prefetch" href="/assets/js/48.adb143bb.js"><link rel="prefetch" href="/assets/js/49.fd27f7d0.js"><link rel="prefetch" href="/assets/js/5.69487806.js"><link rel="prefetch" href="/assets/js/6.8d81f0ec.js"><link rel="prefetch" href="/assets/js/7.3bd43f9a.js"><link rel="prefetch" href="/assets/js/8.f6a07905.js"><link rel="prefetch" href="/assets/js/9.36b4852e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7b36eabc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">流浪地球</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/java_1.html" class="nav-link">
  jobHandler调度管理
</a></li><li class="dropdown-item"><!----> <a href="/Java/java_2.html" class="nav-link">
  jProtobuf尝鲜
</a></li><li class="dropdown-item"><!----> <a href="/SpringBoot/springboot_1.html" class="nav-link">
  使用Docker部署Spring Boot
</a></li><li class="dropdown-item"><!----> <a href="/SpringCloud/springcloud_1.html" class="nav-link">
  springcloud(一)：初识Spring Cloud
</a></li><li class="dropdown-item"><!----> <a href="/SpringCloud/springcloud_2.html" class="nav-link">
  springcloud(二)：注册中心Eureka
</a></li><li class="dropdown-item"><!----> <a href="/Java/java_3.html" class="nav-link">
  java8 toMap问题(key重复如何解决)
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据" class="dropdown-title"><span class="title">大数据</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据" class="mobile-dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BigData/bigdata_1.html" class="nav-link">
  使用Docker搭建Hadoop集群(伪分布式与完全分布式)
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="区块链" class="dropdown-title"><span class="title">区块链</span> <span class="arrow down"></span></button> <button type="button" aria-label="区块链" class="mobile-dropdown-title"><span class="title">区块链</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BlockChain/block_1.html" class="nav-link">
  1、Java实现简单区块链
</a></li><li class="dropdown-item"><!----> <a href="/BlockChain/block_2.html" class="nav-link">
  2、Java实现可交易钱包
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Go/go_1.html" class="nav-link">
  go的基本命令详解
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_2.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  gin框架使用案例
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_3.html" class="nav-link">
  gorm基本使用
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_4.html" class="nav-link">
  Golang操作Redis
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_5.html" class="nav-link">
  golang实现tcp通信
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_6.html" class="nav-link">
  Golang使用Protobuf 
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Linux" class="dropdown-title"><span class="title">Linux</span> <span class="arrow down"></span></button> <button type="button" aria-label="Linux" class="mobile-dropdown-title"><span class="title">Linux</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Linux/linux_1.html" class="nav-link">
  虚拟机3种网络模式
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_2.html" class="nav-link">
  linux常用命令总结
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_3.html" class="nav-link">
  centos7部署FastDFS
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_4.html" class="nav-link">
  centos7中根据文件大小排序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Docker" class="dropdown-title"><span class="title">Docker</span> <span class="arrow down"></span></button> <button type="button" aria-label="Docker" class="mobile-dropdown-title"><span class="title">Docker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Docker/docker_1.html" class="nav-link">
  Docker(一)：Docker入门教程
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_2.html" class="nav-link">
  Docker(二)：Dockerfile使用介绍
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_3.html" class="nav-link">
  Docker(三)：Dockerfile命令详解
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_4.html" class="nav-link">
  Docker(四)：Docker三剑客之Docker Compose
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_5.html" class="nav-link">
  Docker(五)：Docker三剑客之Docker Machine
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_6.html" class="nav-link">
  Docker(六)：Docker三剑客之Docker Swarm
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_7.html" class="nav-link">
  Docker安装MariaDB
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_9.html" class="nav-link">
  Docker安装Mysql8
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_8.html" class="nav-link">
  Docker安装Redis
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_10.html" class="nav-link">
  Docker安装Nacos
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="K8s" class="dropdown-title"><span class="title">K8s</span> <span class="arrow down"></span></button> <button type="button" aria-label="K8s" class="mobile-dropdown-title"><span class="title">K8s</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/K8s/k8s_1.html" class="nav-link">
  VirtualBox + centos7部署k8s
</a></li><li class="dropdown-item"><!----> <a href="/K8s/k8s_2.html" class="nav-link">
  kubectl常用命令
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Nginx" class="dropdown-title"><span class="title">Nginx</span> <span class="arrow down"></span></button> <button type="button" aria-label="Nginx" class="mobile-dropdown-title"><span class="title">Nginx</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OpenResty/nginx.html" class="nav-link">
  Nginx 配置详解
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/nginx_2.html" class="nav-link">
  Nginx 常用命令
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/openresty_1.html" class="nav-link">
  OpenResty 使用介绍
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/openresty_2.html" class="nav-link">
  OpenResty(Nginx+Lua)测试用例
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Jenkins" class="dropdown-title"><span class="title">Jenkins</span> <span class="arrow down"></span></button> <button type="button" aria-label="Jenkins" class="mobile-dropdown-title"><span class="title">Jenkins</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Jenkins/jenkins_1.html" class="nav-link">
  快速安装Jenkins完美教程
</a></li><li class="dropdown-item"><!----> <a href="/Jenkins/jenkins_2.html" class="nav-link">
  Docker jenkins配置NPM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其它" class="dropdown-title"><span class="title">其它</span> <span class="arrow down"></span></button> <button type="button" aria-label="其它" class="mobile-dropdown-title"><span class="title">其它</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Other/2019.1.2.html" class="nav-link">
  Vuepress搭建静态博客
</a></li><li class="dropdown-item"><!----> <a href="/Other/markdown.html" class="nav-link">
  Markdown基本语法
</a></li></ul></div></div><div class="nav-item"><a href="/Readme/index.html" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Java/java_1.html" class="nav-link">
  jobHandler调度管理
</a></li><li class="dropdown-item"><!----> <a href="/Java/java_2.html" class="nav-link">
  jProtobuf尝鲜
</a></li><li class="dropdown-item"><!----> <a href="/SpringBoot/springboot_1.html" class="nav-link">
  使用Docker部署Spring Boot
</a></li><li class="dropdown-item"><!----> <a href="/SpringCloud/springcloud_1.html" class="nav-link">
  springcloud(一)：初识Spring Cloud
</a></li><li class="dropdown-item"><!----> <a href="/SpringCloud/springcloud_2.html" class="nav-link">
  springcloud(二)：注册中心Eureka
</a></li><li class="dropdown-item"><!----> <a href="/Java/java_3.html" class="nav-link">
  java8 toMap问题(key重复如何解决)
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="大数据" class="dropdown-title"><span class="title">大数据</span> <span class="arrow down"></span></button> <button type="button" aria-label="大数据" class="mobile-dropdown-title"><span class="title">大数据</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BigData/bigdata_1.html" class="nav-link">
  使用Docker搭建Hadoop集群(伪分布式与完全分布式)
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="区块链" class="dropdown-title"><span class="title">区块链</span> <span class="arrow down"></span></button> <button type="button" aria-label="区块链" class="mobile-dropdown-title"><span class="title">区块链</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/BlockChain/block_1.html" class="nav-link">
  1、Java实现简单区块链
</a></li><li class="dropdown-item"><!----> <a href="/BlockChain/block_2.html" class="nav-link">
  2、Java实现可交易钱包
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Go" class="dropdown-title"><span class="title">Go</span> <span class="arrow down"></span></button> <button type="button" aria-label="Go" class="mobile-dropdown-title"><span class="title">Go</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Go/go_1.html" class="nav-link">
  go的基本命令详解
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_2.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  gin框架使用案例
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_3.html" class="nav-link">
  gorm基本使用
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_4.html" class="nav-link">
  Golang操作Redis
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_5.html" class="nav-link">
  golang实现tcp通信
</a></li><li class="dropdown-item"><!----> <a href="/Go/go_6.html" class="nav-link">
  Golang使用Protobuf 
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Linux" class="dropdown-title"><span class="title">Linux</span> <span class="arrow down"></span></button> <button type="button" aria-label="Linux" class="mobile-dropdown-title"><span class="title">Linux</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Linux/linux_1.html" class="nav-link">
  虚拟机3种网络模式
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_2.html" class="nav-link">
  linux常用命令总结
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_3.html" class="nav-link">
  centos7部署FastDFS
</a></li><li class="dropdown-item"><!----> <a href="/Linux/linux_4.html" class="nav-link">
  centos7中根据文件大小排序
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Docker" class="dropdown-title"><span class="title">Docker</span> <span class="arrow down"></span></button> <button type="button" aria-label="Docker" class="mobile-dropdown-title"><span class="title">Docker</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Docker/docker_1.html" class="nav-link">
  Docker(一)：Docker入门教程
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_2.html" class="nav-link">
  Docker(二)：Dockerfile使用介绍
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_3.html" class="nav-link">
  Docker(三)：Dockerfile命令详解
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_4.html" class="nav-link">
  Docker(四)：Docker三剑客之Docker Compose
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_5.html" class="nav-link">
  Docker(五)：Docker三剑客之Docker Machine
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_6.html" class="nav-link">
  Docker(六)：Docker三剑客之Docker Swarm
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_7.html" class="nav-link">
  Docker安装MariaDB
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_9.html" class="nav-link">
  Docker安装Mysql8
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_8.html" class="nav-link">
  Docker安装Redis
</a></li><li class="dropdown-item"><!----> <a href="/Docker/docker_10.html" class="nav-link">
  Docker安装Nacos
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="K8s" class="dropdown-title"><span class="title">K8s</span> <span class="arrow down"></span></button> <button type="button" aria-label="K8s" class="mobile-dropdown-title"><span class="title">K8s</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/K8s/k8s_1.html" class="nav-link">
  VirtualBox + centos7部署k8s
</a></li><li class="dropdown-item"><!----> <a href="/K8s/k8s_2.html" class="nav-link">
  kubectl常用命令
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Nginx" class="dropdown-title"><span class="title">Nginx</span> <span class="arrow down"></span></button> <button type="button" aria-label="Nginx" class="mobile-dropdown-title"><span class="title">Nginx</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/OpenResty/nginx.html" class="nav-link">
  Nginx 配置详解
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/nginx_2.html" class="nav-link">
  Nginx 常用命令
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/openresty_1.html" class="nav-link">
  OpenResty 使用介绍
</a></li><li class="dropdown-item"><!----> <a href="/OpenResty/openresty_2.html" class="nav-link">
  OpenResty(Nginx+Lua)测试用例
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Jenkins" class="dropdown-title"><span class="title">Jenkins</span> <span class="arrow down"></span></button> <button type="button" aria-label="Jenkins" class="mobile-dropdown-title"><span class="title">Jenkins</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Jenkins/jenkins_1.html" class="nav-link">
  快速安装Jenkins完美教程
</a></li><li class="dropdown-item"><!----> <a href="/Jenkins/jenkins_2.html" class="nav-link">
  Docker jenkins配置NPM
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其它" class="dropdown-title"><span class="title">其它</span> <span class="arrow down"></span></button> <button type="button" aria-label="其它" class="mobile-dropdown-title"><span class="title">其它</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Other/2019.1.2.html" class="nav-link">
  Vuepress搭建静态博客
</a></li><li class="dropdown-item"><!----> <a href="/Other/markdown.html" class="nav-link">
  Markdown基本语法
</a></li></ul></div></div><div class="nav-item"><a href="/Readme/index.html" class="nav-link">
  关于我
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="gin框架使用案例"><a href="#gin框架使用案例" class="header-anchor">#</a> gin框架使用案例</h1> <h2 id="_1-介绍"><a href="#_1-介绍" class="header-anchor">#</a> 1. 介绍</h2> <p>Gin 是一个用 Golang编写的 高性能的web 框架, 由于http路由的优化，速度提高了近 40 倍。 Gin的特点就是封装优雅、API友好。</p> <p>Gin的一些特性：</p> <p>快速 基于 Radix 树的路由，小内存占用。没有反射。可预测的 API 性能。</p> <p>支持中间件 传入的 HTTP 请求可以由一系列中间件和最终操作来处理。 例如：Logger，Authorization，GZIP，最终操作 DB。</p> <p>Crash 处理 Gin 可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它。这样，你的服务器将始终可用。例如，你可以向 Sentry 报告这个 panic！</p> <p>JSON 验证 Gin 可以解析并验证请求的 JSON，例如检查所需值的存在。</p> <p>路由组 更好地组织路由。是否需要授权，不同的 API 版本…… 此外，这些组可以无限制地嵌套而不会降低性能。</p> <p>错误管理 Gin 提供了一种方便的方法来收集 HTTP 请求期间发生的所有错误。最终，中间件可以将它们写入日志文件，数据库并通过网络发送。</p> <p>内置渲染 Gin 为 JSON，XML 和 HTML 渲染提供了易于使用的 API。</p> <p>可扩展性 新建一个中间件非常简单。</p> <h2 id="_2-安装包"><a href="#_2-安装包" class="header-anchor">#</a> 2.安装包</h2> <p>提示：依赖 Go 1.6 及以上版本</p> <p>下载并安装 gin</p> <div class="language- extra-class"><pre class="language-text"><code>go get -u github.com/gin-gonic/gin
</code></pre></div><h2 id="_3-一个简单http-server的例子"><a href="#_3-一个简单http-server的例子" class="header-anchor">#</a> 3.一个简单http server的例子</h2> <div class="language- extra-class"><pre class="language-text"><code>package main
// 导入gin包
import &quot;github.com/gin-gonic/gin&quot;
​
// 入口函数
func main() {
    // 初始化一个http服务对象
    r := gin.Default()
        
    // 设置一个get请求的路由，url为/ping, 处理函数（或者叫控制器函数）是一个闭包函数。
    r.GET(&quot;/ping&quot;, func(c *gin.Context) {
        // 通过请求上下文对象Context, 直接往客户端返回一个json
        c.JSON(200, gin.H{
            &quot;message&quot;: &quot;pong&quot;,
        })
    })
    
    r.Run() // 监听并在 0.0.0.0:8080 上启动服务
}
</code></pre></div><p>将代码保存至demo.go文件中，然后, 执行 <code>go run demo.go</code> 命令来运行代码, 然后就可以通过<code>localhost:8080/ping</code> 访问了。</p> <h2 id="_4-项目结构"><a href="#_4-项目结构" class="header-anchor">#</a> 4.项目结构</h2> <p>实际项目业务功能和模块会很多，我们不可能把所有代码都写在一个go文件里面或者写在一个main入口函数里面；我们需要对项目结构做一些规划，方便维护代码以及扩展。</p> <p>Gin框没有对项目结构做出限制，我们可以根据自己项目需要自行设计。</p> <p>这里给出一个典型的MVC框架大致的项目结构的例子，大家可以参考下：</p> <div class="language- extra-class"><pre class="language-text"><code>├── conf                    #项目配置文件目录
│   └── config.toml         #大家可以选择自己熟悉的配置文件管理工具包例如：toml、xml等等
├── controllers             #控制器目录，按模块存放控制器（或者叫控制器函数），必要的时候可以继续划分子目录。
│   ├── food.go
│   └── user.go
├── main.go                 #项目入口，这里负责Gin框架的初始化，注册路由信息，关联控制器函数等。
├── models                  #模型目录，负责项目的数据存储部分，例如各个模块的Mysql表的读写模型。
│   ├── food.go
│   └── user.go
├── static                  #静态资源目录，包括Js，css，jpg等等，可以通过Gin框架配置，直接让用户访问。
│   ├── css
│   ├── images
│   └── js
├── logs                    #日志文件目录，主要保存项目运行过程中产生的日志。
└── views                   #视图模板目录，存放各个模块的视图模板，当然有些项目只有api，是不需要视图部分，可以忽略这个目录
    └── index.html
</code></pre></div><h2 id="_5-gin框架运行模式"><a href="#_5-gin框架运行模式" class="header-anchor">#</a> 5.Gin框架运行模式</h2> <p>为方便调试，Gin 框架在运行的时候默认是debug模式，在控制台默认会打印出很多调试日志，上线的时候我们需要关闭debug模式，改为release模式。</p> <p>设置Gin框架运行模式：</p> <h3 id="_5-1-通过环境变量设置"><a href="#_5-1-通过环境变量设置" class="header-anchor">#</a> 5.1.通过环境变量设置</h3> <div class="language- extra-class"><pre class="language-text"><code>export GIN_MODE=release
</code></pre></div><p>GIN_MODE环境变量，可以设置为debug或者release</p> <h3 id="_5-2-通过代码设置"><a href="#_5-2-通过代码设置" class="header-anchor">#</a> 5.2.通过代码设置</h3> <p>在main函数，初始化gin框架的时候执行下面代码</p> <div class="language- extra-class"><pre class="language-text"><code>// 设置 release模式
gin.SetMode(gin.ReleaseMode)
// 或者 设置debug模式
gin.SetMode(gin.DebugMode)
</code></pre></div><h2 id="gin路由与控制器"><a href="#gin路由与控制器" class="header-anchor">#</a> Gin路由与控制器</h2> <h3 id="_1-概述"><a href="#_1-概述" class="header-anchor">#</a> 1.概述</h3> <p>路由是一个过程，指的是一个http请求，如何找到对应的处理器函数（也可以叫控制器函数）,Gin框架的路由是基于httprouter包实现的。</p> <p>控制器函数主要负责执行http请求-响应任务。</p> <p>一个简单的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>r := gin.Default()
​
// 路由定义post请求, url路径为：/user/login, 绑定doLogin控制器函数
r.POST(&quot;/user/login&quot;, doLogin)
​
// 控制器函数
func doLogin(c *gin.Context) {
        // 获取post请求参数
    username := c.PostForm(&quot;username&quot;)
    password := c.PostForm(&quot;password&quot;)
​
    // 通过请求上下文对象Context, 直接往客户端返回一个字符串
    c.String(200, &quot;username=%s,password=%s&quot;, username,password)
}
</code></pre></div><h3 id="_2-路由规则"><a href="#_2-路由规则" class="header-anchor">#</a> 2.路由规则</h3> <p>一条路由规则由三部分组成：</p> <p>http请求方法</p> <p>url路径</p> <p>控制器函数</p> <h4 id="_1-http请求方法"><a href="#_1-http请求方法" class="header-anchor">#</a> 1.http请求方法</h4> <p>常用的http请求方法有下面4种:</p> <p>GET</p> <p>POST</p> <p>PUT</p> <p>DELETE</p> <h4 id="_2-url路径"><a href="#_2-url路径" class="header-anchor">#</a> 2.url路径</h4> <p>echo框架，url路径有三种写法：</p> <p>静态url路径</p> <p>带路径参数的url路径</p> <p>带星号（*）模糊匹配参数的url路径</p> <p>下面看下各种url路由的例子</p> <div class="language- extra-class"><pre class="language-text"><code>// 例子1， 静态Url路径, 即不带任何参数的url路径
/users/center
/user/111
/food/12
​
// 例子2，带路径参数的url路径，url路径上面带有参数,参数由冒号（:）跟着一个字符串定义。
// 路径参数值可以是数值，也可以是字符串
​
//定义参数:id， 可以匹配/user/1, /user/899 /user/xiaoli 这类Url路径
/user/:id
​
//定义参数:id， 可以匹配/food/2, /food/100 /food/apple 这类Url路径
/food/:id
​
//定义参数:type和:page， 可以匹配/foods/2/1, /food/100/25 /food/apple/30 这类Url路径
/foods/:type/:page
​
// 例子3. 带星号（*）模糊匹配参数的url路径
// 星号代表匹配任意路径的意思, 必须在*号后面指定一个参数名，后面可以通过这个参数获取*号匹配的内容。
​
//以/foods/ 开头的所有路径都匹配
//匹配：/foods/1， /foods/200, /foods/1/20, /foods/apple/1 
/foods/*path
​
//可以通过path参数获取*号匹配的内容。
</code></pre></div><h4 id="_3-控制器函数"><a href="#_3-控制器函数" class="header-anchor">#</a> 3.控制器函数</h4> <p>控制器函数定义：</p> <div class="language- extra-class"><pre class="language-text"><code>func HandlerFunc(c *gin.Context)
</code></pre></div><p>控制器函数接受一个上下文参数。 可以通过上下文参数，获取http请求参数，响应http请求。</p> <h4 id="_4-路由定义例子"><a href="#_4-路由定义例子" class="header-anchor">#</a> 4.路由定义例子</h4> <div class="language- extra-class"><pre class="language-text"><code>//实例化gin实例对象。
r := gin.Default()
    
//定义post请求, url路径为：/users, 绑定saveUser控制器函数
r.POST(&quot;/users&quot;, saveUser)
​
//定义get请求，url路径为：/users/:id  （:id是参数，例如: /users/10, 会匹配这个url模式），绑定getUser控制器函数
r.GET(&quot;/users/:id&quot;, getUser)
​
//定义put请求
r.PUT(&quot;/users/:id&quot;, updateUser)
​
//定义delete请求
r.DELETE(&quot;/users/:id&quot;, deleteUser)
​
​
//控制器函数实现
func saveUser(c *gin.Context) {
    ...忽略实现...
}
​
func getUser(c *gin.Context) {
    ...忽略实现...
}
​
func updateUser(c *gin.Context) {
    ...忽略实现...
}
​
func deleteUser(c *gin.Context) {
    ...忽略实现...
}
</code></pre></div><p>提示：实际项目开发中不要把路由定义和控制器函数都写在一个go文件，不方便维护，可以参考第一章的项目结构，规划自己的业务模块。</p> <h3 id="_3-分组路由"><a href="#_3-分组路由" class="header-anchor">#</a> 3.分组路由</h3> <p>在做api开发的时候，如果要支持多个api版本，我们可以通过分组路由来实现api版本处理。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>func main() {
    router := gin.Default()
​
    // 创建v1组
    v1 := router.Group(&quot;/v1&quot;)
    {
                // 在v1这个分组下，注册路由
        v1.POST(&quot;/login&quot;, loginEndpoint)
        v1.POST(&quot;/submit&quot;, submitEndpoint)
        v1.POST(&quot;/read&quot;, readEndpoint)
    }
​
    // 创建v2组
    v2 := router.Group(&quot;/v2&quot;)
    {
                // 在v2这个分组下，注册路由
        v2.POST(&quot;/login&quot;, loginEndpoint)
        v2.POST(&quot;/submit&quot;, submitEndpoint)
        v2.POST(&quot;/read&quot;, readEndpoint)
    }
​
    router.Run(&quot;:8080&quot;)
}
</code></pre></div><p>上面的例子将会注册下面的路由信息：</p> <p>/v1/login</p> <p>/v1/submit</p> <p>/v1/read</p> <p>/v2/login</p> <p>/v2/submit</p> <p>/v2/read</p> <p>路由分组，其实就是设置了同一类路由的url前缀。</p> <h2 id="gin如何处理请求参数"><a href="#gin如何处理请求参数" class="header-anchor">#</a> Gin如何处理请求参数</h2> <p>本章介绍Gin框架获取请求参数的方式</p> <h3 id="_1-获取get-请求参数"><a href="#_1-获取get-请求参数" class="header-anchor">#</a> 1.获取Get 请求参数</h3> <p>Get请求url例子：<code>/path?id=1234&amp;name=Manu&amp;value=111</code></p> <p>获取Get请求参数的常用函数：</p> <div class="language- extra-class"><pre class="language-text"><code>func (c *Context) Query(key string) string

func (c *Context) DefaultQuery(key, defaultValue string) string

func (c *Context) GetQuery(key string) (string, bool)
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>func Handler(c *gin.Context) {
    //获取name参数, 通过Query获取的参数值是String类型。
    name := c.Query(&quot;name&quot;)
​
        //获取name参数, 跟Query函数的区别是，可以通过第二个参数设置默认值。
        name := c.DefaultQuery(&quot;name&quot;, &quot;tizi365&quot;)
​
    //获取id参数, 通过GetQuery获取的参数值也是String类型, 
    // 区别是GetQuery返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。
    id, ok := c.GetQuery(&quot;id&quot;)
        if !ok {
       // 参数不存在
    }
}
</code></pre></div><p>提示：GetQuery函数，判断参数是否存在的逻辑是，参数值为空，参数也算存在，只有没有提交参数，才算参数不存在。</p> <h3 id="_2-获取post请求参数"><a href="#_2-获取post请求参数" class="header-anchor">#</a> 2.获取Post请求参数</h3> <p>获取Post请求参数的常用函数：</p> <div class="language- extra-class"><pre class="language-text"><code>func (c *Context) PostForm(key string) string

func (c *Context) DefaultPostForm(key, defaultValue string) string

func (c *Context) GetPostForm(key string) (string, bool)
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>func Handler(c *gin.Context) {
    //获取name参数, 通过PostForm获取的参数值是String类型。
    name := c.PostForm(&quot;name&quot;)
​
    // 跟PostForm的区别是可以通过第二个参数设置参数默认值
    name := c.DefaultPostForm(&quot;name&quot;, &quot;tizi365&quot;)
​
    //获取id参数, 通过GetPostForm获取的参数值也是String类型,
    // 区别是GetPostForm返回两个参数，第一个是参数值，第二个参数是参数是否存在的bool值，可以用来判断参数是否存在。
    id, ok := c.GetPostForm(&quot;id&quot;)
    if !ok {
        // 参数不存在
    }
}
</code></pre></div><h3 id="_3-获取url路径参数"><a href="#_3-获取url路径参数" class="header-anchor">#</a> 3.获取URL路径参数</h3> <p>获取URL路径参数，指的是获取 /user/:id 这类型路由绑定的参数，这个例子绑定了一个参数id。</p> <p>获取url路径参数常用函数：</p> <div class="language- extra-class"><pre class="language-text"><code>func (c *Context) Param(key string) string
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>r := gin.Default()
    
r.GET(&quot;/user/:id&quot;, func(c *gin.Context) {
    // 获取url参数id
    id := c.Param(&quot;id&quot;)
})
</code></pre></div><h3 id="_4-将请求参数绑定到struct对象"><a href="#_4-将请求参数绑定到struct对象" class="header-anchor">#</a> 4.将请求参数绑定到struct对象</h3> <p>前面获取参数的方式都是一个个参数的读取，比较麻烦，Gin框架支持将请求参数自动绑定到一个struct对象，这种方式支持Get/Post请求，也支持http请求body内容为json/xml格式的参数。</p> <p>例子：</p> <p>下面例子是将请求参数绑定到User struct对象。</p> <div class="language- extra-class"><pre class="language-text"><code>// User 结构体定义
type User struct {
  Name  string `json:&quot;name&quot; form:&quot;name&quot;`
  Email string `json:&quot;email&quot; form:&quot;email&quot;`
}
</code></pre></div><p>通过定义struct字段的标签，定义请求参数和struct字段的关系。 下面对User的Name字段的标签进行说明。</p> <p>struct标签说明：</p> <p>标签	说明
json:&quot;name&quot;	数据格式为json格式，并且json字段名为name
form:&quot;name&quot;	表单参数名为name
提示：你可以根据自己的需要选择支持的数据类型，例如需要支持json数据格式，可以这样定义字段标签: json:&quot;name&quot;</p> <p>下面看下控制器代码：</p> <div class="language- extra-class"><pre class="language-text"><code>r.POST(&quot;/user/:id&quot;, func(c *gin.Context) {
   // 初始化user struct
   u := User{}
   // 通过ShouldBind函数，将请求参数绑定到struct对象， 处理json请求代码是一样的。
   // 如果是post请求则根据Content-Type判断，接收的是json数据，还是普通的http请求参数
   if c.ShouldBind(&amp;u) == nil {
     // 绑定成功， 打印请求参数
     log.Println(u.Name)
     log.Println(u.Email)
​
    }
    // http 请求返回一个字符串 
    c.String(200, &quot;Success&quot;)
})
</code></pre></div><p>提示：如果你通过http请求body传递json格式的请求参数，并且通过post请求的方式提交参数，则需要将Content-Type设置为application/json, 如果是xml格式的数据，则设置为application/xml</p> <h3 id="_5-gin如何获取客户ip"><a href="#_5-gin如何获取客户ip" class="header-anchor">#</a> 5.Gin如何获取客户ip</h3> <div class="language- extra-class"><pre class="language-text"><code>r := gin.Default()
    
r.GET(&quot;/ip&quot;, func(c *gin.Context) {
    // 获取用户IP
    ip := c.ClientIP()
})
</code></pre></div><h2 id="gin处理请求结果"><a href="#gin处理请求结果" class="header-anchor">#</a> Gin处理请求结果</h2> <p>本章介绍处理完http请求后如何响应请求，Gin框架支持以字符串、json、xml、文件等格式响应请求。</p> <p>gin.Context上下文对象支持多种返回处理结果，下面分别介绍不同的响应方式。</p> <h3 id="_1-以字符串方式响应请求"><a href="#_1-以字符串方式响应请求" class="header-anchor">#</a> 1.以字符串方式响应请求</h3> <p>通过String函数返回字符串。</p> <p>函数定义：</p> <div class="language- extra-class"><pre class="language-text"><code>func (c *Context) String(code int, format string, values ...interface{})
</code></pre></div><p>参数说明：</p> <p>参数	说明
code	http状态码
format	返回结果，支持类似Sprintf函数一样的字符串格式定义，例如,%d 代表插入整数，%s代表插入字符串
values	任意个format参数定义的字符串格式参数
例子：</p> <div class="language- extra-class"><pre class="language-text"><code>func Handler(c *gin.Context)  {
    // 例子1：
    c.String(200, &quot;欢迎访问tizi360.com!&quot;)
    
    // 例子2： 这里定义了两个字符串参数（两个%s），后面传入的两个字符串参数将会替换对应的%s
    c.String(200,&quot;欢迎访问%s, 你是%s&quot;, &quot;tizi360.com!&quot;,&quot;最靓的仔！&quot;)
}
</code></pre></div><p>提示： net/http包定义了多种常用的状态码常量，例如：http.StatusOK == 200， http.StatusMovedPermanently == 301， http.StatusNotFound == 404等，具体可以参考net/http包</p> <h3 id="_2-以json格式响应请求"><a href="#_2-以json格式响应请求" class="header-anchor">#</a> 2.以json格式响应请求</h3> <p>我们开发api接口的时候常用的格式就是json，下面是返回json格式数据的例子</p> <div class="language- extra-class"><pre class="language-text"><code>// User 定义
type User struct {
  Name  string `json:&quot;name&quot;` // 通过json标签定义struct字段转换成json字段的名字。
  Email string `json:&quot;email&quot;`
}
​
// Handler 控制器
func(c *gin.Context) {
  //初始化user对象
  u := &amp;User{
    Name:  &quot;tizi365&quot;,
    Email: &quot;tizi@tizi365.com&quot;,
  }
  //返回json数据
  //返回结果：{&quot;name&quot;:&quot;tizi365&quot;, &quot;email&quot;:&quot;tizi@tizi365.com&quot;}
  c.JSON(200, u)
}
</code></pre></div><h3 id="_3-以xml格式响应请求"><a href="#_3-以xml格式响应请求" class="header-anchor">#</a> 3.以xml格式响应请求</h3> <div class="language- extra-class"><pre class="language-text"><code>// User 定义, 默认struct的名字就是xml的根节点名字，这里转换成xml后根节点的名字为User.
type User struct {
  Name  string `xml:&quot;name&quot;` // 通过xml标签定义struct字段转换成xml字段的名字。
  Email string `xml:&quot;email&quot;`
}
​
// Handler 控制器
func(c *gin.Context) {
  //初始化user对象
  u := &amp;User{
    Name:  &quot;tizi365&quot;,
    Email: &quot;tizi@tizi365.com&quot;,
  }
  //返回xml数据
  //返回结果：
  //  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  //  &lt;User&gt;&lt;name&gt;tizi365&lt;/name&gt;&lt;email&gt;tizi@tizi365.com&lt;/email&gt;&lt;/User&gt;
  c.XML(200, u)
}
</code></pre></div><h3 id="_4-以文件格式响应请求"><a href="#_4-以文件格式响应请求" class="header-anchor">#</a> 4.以文件格式响应请求</h3> <p>下面介绍gin框架如何直接返回一个文件，可以用来做文件下载。</p> <p>例子1：</p> <div class="language- extra-class"><pre class="language-text"><code>func(c *gin.Context) {
  //通过File函数，直接返回本地文件，参数为本地文件地址。
  //函数说明：c.File(&quot;文件路径&quot;)
  c.File(&quot;/var/www/1.jpg&quot;)
}
</code></pre></div><p>​
例子2：</p> <div class="language- extra-class"><pre class="language-text"><code>func(c *gin.Context) {
  //通过FileAttachment函数，返回本地文件，类似File函数，区别是可以指定下载的文件名。
  //函数说明: c.FileAttachment(&quot;文件路径&quot;, &quot;下载的文件名&quot;)
  c.FileAttachment(&quot;/var/www/1.jpg&quot;, &quot;1.jpg&quot;)
}
</code></pre></div><h3 id="_5-设置http响应头-设置header"><a href="#_5-设置http响应头-设置header" class="header-anchor">#</a> 5.设置http响应头（设置Header）</h3> <div class="language- extra-class"><pre class="language-text"><code>func(c *gin.Context) {
  //设置http响应 header, key/value方式，支持设置多个header
  c.Header(&quot;site&quot;,&quot;tizi365&quot;)
}
</code></pre></div><h2 id="gin框架-html模板处理"><a href="#gin框架-html模板处理" class="header-anchor">#</a> Gin框架 html模板处理</h2> <p>Gin 框架默认封装了golang内置的html/template包用于处理html模版，如果你开发的是接口服务，不提供html页面可以跳过本章内容。</p> <p>前置技术知识点：</p> <p>模板引擎 - 点击Go模板引擎教程，学习完整的模板引擎语法。</p> <h3 id="_1-返回html结果的例子"><a href="#_1-返回html结果的例子" class="header-anchor">#</a> 1.返回html结果的例子</h3> <div class="language- extra-class"><pre class="language-text"><code>func main() {
        // 初始化gin对象
    router := gin.Default()
        // 首先加载templates目录下面的所有模版文件，模版文件扩展名随意
    router.LoadHTMLGlob(&quot;templates/*&quot;)
​
        // 绑定一个url路由 /index
    router.GET(&quot;/index&quot;, func(c *gin.Context) {
                // 通过HTML函数返回html代码
                // 第二个参数是模版文件名字
                // 第三个参数是map类型，代表模版参数
                // gin.H 是map[string]interface{}类型的别名
        c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{
            &quot;title&quot;: &quot;Main website&quot;,
        })
    })
        // 启动http服务，并且绑定在8080端口
    router.Run(&quot;:8080&quot;)
}
</code></pre></div><p>模版代码</p> <p>文件名：templates/index.html</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
    &lt;h1&gt;
        {{ .title }}
    &lt;/h1&gt;
&lt;/html&gt;
</code></pre></div><h3 id="_2-处理模版子目录的情况"><a href="#_2-处理模版子目录的情况" class="header-anchor">#</a> 2.处理模版子目录的情况</h3> <p>一般在项目中，因为有多个模块的模版文件，我们都会以多个子目录的方式来组织模版文件，上面的例子只能加载某个目录下面的模版文件，无法加载子目录的模版文件。</p> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>func main() {
    router := gin.Default()
        // 加载templates目录下面的所有模版文件，包括子目录
       // **/* 代表所有子目录下的所有文件
    router.LoadHTMLGlob(&quot;templates/**/*&quot;)
​
    router.GET(&quot;/posts/index&quot;, func(c *gin.Context) {
                // 子目录的模版文件，需要加上目录名，例如：posts/index.tmpl
        c.HTML(http.StatusOK, &quot;posts/index.tmpl&quot;, gin.H{
            &quot;title&quot;: &quot;Posts&quot;,
        })
    })
    router.GET(&quot;/users/index&quot;, func(c *gin.Context) {
                // 子目录的模版文件，需要加上目录名，例如：users/index.tmpl
        c.HTML(http.StatusOK, &quot;users/index.tmpl&quot;, gin.H{
            &quot;title&quot;: &quot;Users&quot;,
        })
    })
    router.Run(&quot;:8080&quot;)
}
</code></pre></div><p>模版文件：templates/posts/index.tmpl</p> <div class="language- extra-class"><pre class="language-text"><code>{{ define &quot;posts/index.tmpl&quot; }}
&lt;html&gt;&lt;h1&gt;
    {{ .title }}
&lt;/h1&gt;
&lt;p&gt;Using posts/index.tmpl&lt;/p&gt;
&lt;/html&gt;
{{ end }}
模版文件：templates/users/index.tmpl

{{ define &quot;users/index.tmpl&quot; }}
&lt;html&gt;&lt;h1&gt;
    {{ .title }}
&lt;/h1&gt;
&lt;p&gt;Using users/index.tmpl&lt;/p&gt;
&lt;/html&gt;
{{ end }}
</code></pre></div><h2 id="gin框架如何访问静态资源文件"><a href="#gin框架如何访问静态资源文件" class="header-anchor">#</a> Gin框架如何访问静态资源文件</h2> <p>如果项目中包含js、css、jpg之类的静态文件，怎么访问访问静态文件？</p> <p>下面例子介绍如何处理访问静态资源文件：</p> <div class="language- extra-class"><pre class="language-text"><code>func main() {
    router := gin.Default()
        // 设置静态资源文件目录，并且绑定一个Url前缀
        // 静态资源文件目录：/var/www/tizi365/assets
        // /assets是访问静态资源的url前缀
        // 例如：
        //   /assets/images/1.jpg 这个url文件，存储在/var/www/tizi365/assets/images/1.jpg
    router.Static(&quot;/assets&quot;, &quot;/var/www/tizi365/assets&quot;)
​
        // 为单个静态资源文件，绑定url
        // 这里的意思就是将/favicon.ico这个url，绑定到./resources/favicon.ico这个文件
    router.StaticFile(&quot;/favicon.ico&quot;, &quot;./resources/favicon.ico&quot;)
​
    // Listen and serve on 0.0.0.0:8080
    router.Run(&quot;:8080&quot;)
}
</code></pre></div><p>提示：设置/favicon.ico这个url，其实就是为网站设置图标，浏览器默认会将这个url作为网站默认图标。</p> <h2 id="gin框架如何处理cookie"><a href="#gin框架如何处理cookie" class="header-anchor">#</a> Gin框架如何处理cookie</h2> <p>cookie通常用于在浏览器中保存一些小数据，例如客户标识、用户非铭感数据。注意别使用cookie保存隐私数据。</p> <p>gin框架主要通过上下文对象提供的SetCookie和Cookie两个函数操作cookie</p> <h3 id="_1-设置cookie"><a href="#_1-设置cookie" class="header-anchor">#</a> 1.设置cookie</h3> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>import (
    &quot;fmt&quot;
​
    &quot;github.com/gin-gonic/gin&quot;
)
​
func main() {
​
    router := gin.Default()
​
    router.GET(&quot;/cookie&quot;, func(c *gin.Context) {
       // 设置cookie
       c.SetCookie(&quot;site_cookie&quot;, &quot;cookievalue&quot;, 3600, &quot;/&quot;, &quot;localhost&quot;, false, true)
    })
​
    router.Run()
</code></pre></div><p>SetCookie函数定义：</p> <div class="language- extra-class"><pre class="language-text"><code>func (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool)
参数说明：

参数名	类型	说明
name	string	cookie名字
value	string	cookie值
maxAge	int	有效时间，单位是秒，MaxAge=0 忽略MaxAge属性，MaxAge&lt;0 相当于删除cookie, 通常可以设置-1代表删除，MaxAge&gt;0 多少秒后cookie失效
path	string	cookie路径
domain	string	cookie作用域
secure	bool	Secure=true，那么这个cookie只能用https协议发送给服务器
httpOnly	bool	设置HttpOnly=true的cookie不能被js获取到
</code></pre></div><h3 id="_2-读取cookie"><a href="#_2-读取cookie" class="header-anchor">#</a> 2.读取cookie</h3> <div class="language- extra-class"><pre class="language-text"><code>func Handler(c *gin.Context) {
      // 根据cookie名字读取cookie值
      data, err := c.Cookie(&quot;site_cookie&quot;)
      if err != nil {
     // 直接返回cookie值
     c.String(200,data)
     return
      }
      c.String(200,&quot;not found!&quot;)
}
</code></pre></div><h3 id="_3-删除coolie"><a href="#_3-删除coolie" class="header-anchor">#</a> 3.删除coolie</h3> <p>通过将cookie的MaxAge设置为-1, 达到删除cookie的目的。</p> <div class="language- extra-class"><pre class="language-text"><code>func Handler(c *gin.Context) {
      // 设置cookie  MaxAge设置为-1，表示删除cookie
       c.SetCookie(&quot;site_cookie&quot;, &quot;cookievalue&quot;, -1, &quot;/&quot;, &quot;localhost&quot;, false, true)
      c.String(200,&quot;删除cookie演示&quot;)
}
</code></pre></div><h2 id="gin框架实现文件上传"><a href="#gin框架实现文件上传" class="header-anchor">#</a> Gin框架实现文件上传</h2> <p>后端代码：</p> <div class="language- extra-class"><pre class="language-text"><code>package main
// 导入gin包
import (
    &quot;fmt&quot;
    &quot;github.com/gin-gonic/gin&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)
​
func main() {
    router := gin.Default()
    // 设置文件上传大小限制，默认是32m
    router.MaxMultipartMemory = 64 &lt;&lt; 20  // 64 MiB
​
    router.POST(&quot;/upload&quot;, func(c *gin.Context) {
        // 获取上传文件，返回的是multipart.FileHeader对象，代表一个文件，里面包含了文件名之类的详细信息
        // file是表单字段名字
        file, _ := c.FormFile(&quot;file&quot;)
        // 打印上传的文件名
        log.Println(file.Filename)
​
        // 将上传的文件，保存到./data/1111.jpg 文件中
        c.SaveUploadedFile(file, &quot;./data/1111.jpg&quot;)
​
        c.String(http.StatusOK, fmt.Sprintf(&quot;'%s' uploaded!&quot;, file.Filename))
    })
    router.Run(&quot;:8080&quot;)
}
html代码：

&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Single file upload&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;上传文件演示&lt;/h1&gt;
​
&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;上传文件&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><h2 id="gin框架中间件"><a href="#gin框架中间件" class="header-anchor">#</a> Gin框架中间件</h2> <p>在Gin框架中，中间件（Middleware）指的是可以拦截http请求-响应生命周期的特殊函数，在请求-响应生命周期中可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。</p> <h3 id="中间件的常见应用场景如下"><a href="#中间件的常见应用场景如下" class="header-anchor">#</a> 中间件的常见应用场景如下：</h3> <ul><li><p>请求限速</p></li> <li><p>api接口签名处理</p></li> <li><p>权限校验</p></li> <li><p>统一错误处理</p></li></ul> <p>提示：如果你想拦截所有请求做一些事情都可以开发一个中间件函数去实现。</p> <p>Gin支持设置全局中间件和针对路由分组设置中间件，设置全局中间件意思就是会拦截所有请求，针对分组路由设置中间件，意思就是仅对这个分组下的路由起作用。</p> <h4 id="_1-使用中间件"><a href="#_1-使用中间件" class="header-anchor">#</a> 1.使用中间件</h4> <div class="language- extra-class"><pre class="language-text"><code>func main() {
    r := gin.New()
​
    // 通过use设置全局中间件
​
    // 设置日志中间件，主要用于打印请求日志
    r.Use(gin.Logger())
​
    // 设置Recovery中间件，主要用于拦截paic错误，不至于导致进程崩掉
    r.Use(gin.Recovery())
​
    // 忽略后面代码
}
</code></pre></div><h4 id="_2-自定义中间件"><a href="#_2-自定义中间件" class="header-anchor">#</a> 2.自定义中间件</h4> <p>下面通过一个例子，了解如果自定义一个中间件</p> <div class="language- extra-class"><pre class="language-text"><code>package main
// 导入gin包
import (
&quot;github.com/gin-gonic/gin&quot;
    &quot;log&quot;
    &quot;time&quot;
)
​
// 自定义个日志中间件
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        t := time.Now()
​
        // 可以通过上下文对象，设置一些依附在上下文对象里面的键/值数据
        c.Set(&quot;example&quot;, &quot;12345&quot;)
​
        // 在这里处理请求到达控制器函数之前的逻辑
     
        // 调用下一个中间件，或者控制器处理函数，具体得看注册了多少个中间件。
        c.Next()
​
        // 在这里可以处理请求返回给用户之前的逻辑
        latency := time.Since(t)
        log.Print(latency)
​
        // 例如，查询请求状态吗
        status := c.Writer.Status()
        log.Println(status)
    }
}
​
func main() {
    r := gin.New()
    // 注册上面自定义的日志中间件
    r.Use(Logger())
​
    r.GET(&quot;/test&quot;, func(c *gin.Context) {
        // 查询我们之前在日志中间件，注入的键值数据
        example := c.MustGet(&quot;example&quot;).(string)
​
        // it would print: &quot;12345&quot;
        log.Println(example)
    })
​
    // Listen and serve on 0.0.0.0:8080
    r.Run(&quot;:8080&quot;)
}
</code></pre></div><h2 id="gin框架如何处理session"><a href="#gin框架如何处理session" class="header-anchor">#</a> Gin框架如何处理session</h2> <p>在Gin框架中，我们可以依赖gin-contrib/sessions中间件处理session。</p> <p>gin-contrib/sessions中间件支持的存储引擎：</p> <ul><li><p>cookie</p></li> <li><p>memstore</p></li> <li><p>redis</p></li> <li><p>memcached</p></li> <li><p>mongodb</p></li></ul> <p>下面介绍session的用法</p> <h3 id="_1-安装session包"><a href="#_1-安装session包" class="header-anchor">#</a> 1.安装session包</h3> <div class="language- extra-class"><pre class="language-text"><code>go get github.com/gin-contrib/sessions
</code></pre></div><h3 id="_2-基本的session用法"><a href="#_2-基本的session用法" class="header-anchor">#</a> 2.基本的session用法</h3> <div class="language- extra-class"><pre class="language-text"><code>package main
​
import (
        // 导入session包
    &quot;github.com/gin-contrib/sessions&quot;
       // 导入session存储引擎
    &quot;github.com/gin-contrib/sessions/cookie&quot;
        // 导入gin框架包
    &quot;github.com/gin-gonic/gin&quot;
)
​
func main() {
    r := gin.Default()
        // 创建基于cookie的存储引擎，secret11111 参数是用于加密的密钥
    store := cookie.NewStore([]byte(&quot;secret11111&quot;))
        // 设置session中间件，参数mysession，指的是session的名字，也是cookie的名字
       // store是前面创建的存储引擎，我们可以替换成其他存储引擎
    r.Use(sessions.Sessions(&quot;mysession&quot;, store))
​
    r.GET(&quot;/hello&quot;, func(c *gin.Context) {
                // 初始化session对象
        session := sessions.Default(c)
                
                // 通过session.Get读取session值
                // session是键值对格式数据，因此需要通过key查询数据
        if session.Get(&quot;hello&quot;) != &quot;world&quot; {
                        // 设置session数据
            session.Set(&quot;hello&quot;, &quot;world&quot;)
                        // 删除session数据
                        session.Delete(&quot;tizi365&quot;)
                        // 保存session数据
            session.Save()
                        // 删除整个session
                        // session.Clear()
        }
                
        c.JSON(200, gin.H{&quot;hello&quot;: session.Get(&quot;hello&quot;)})
    })
    r.Run(&quot;:8000&quot;)
}
</code></pre></div><h3 id="_2-基于redis存储引擎的session"><a href="#_2-基于redis存储引擎的session" class="header-anchor">#</a> 2.基于redis存储引擎的session</h3> <p>如果我们想将session数据保存到redis中，只要将session的存储引擎改成redis即可。</p> <p>使用redis作为存储引擎的例子：</p> <p>首先安装redis存储引擎的包</p> <div class="language- extra-class"><pre class="language-text"><code>go get github.com/gin-contrib/sessions/redis
</code></pre></div><p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>package main

import (
    &quot;github.com/gin-contrib/sessions&quot;
    &quot;github.com/gin-contrib/sessions/redis&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

func main() {
    r := gin.Default()
    // 初始化基于redis的存储引擎
    // 参数说明：
    //    第1个参数 - redis最大的空闲连接数
    //    第2个参数 - 数通信协议tcp或者udp
    //    第3个参数 - redis地址, 格式，host:port
    //    第4个参数 - redis密码
    //    第5个参数 - session加密密钥
    store, _ := redis.NewStore(10, &quot;tcp&quot;, &quot;localhost:6379&quot;, &quot;&quot;, []byte(&quot;secret&quot;))
    r.Use(sessions.Sessions(&quot;mysession&quot;, store))

    r.GET(&quot;/incr&quot;, func(c *gin.Context) {
        session := sessions.Default(c)
        var count int
        v := session.Get(&quot;count&quot;)
        if v == nil {
            count = 0
        } else {
            count = v.(int)
            count++
        }
        session.Set(&quot;count&quot;, count)
        session.Save()
        c.JSON(200, gin.H{&quot;count&quot;: count})
    })
    r.Run(&quot;:8000&quot;)
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2cd84a3f.js" defer></script><script src="/assets/js/2.63c13255.js" defer></script><script src="/assets/js/21.11dd81d7.js" defer></script>
  </body>
</html>
