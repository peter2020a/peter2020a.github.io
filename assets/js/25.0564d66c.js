(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{298:function(t,e,a){"use strict";a.r(e);var r=a(13),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"golang使用protobuf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#golang使用protobuf"}},[t._v("#")]),t._v(" Golang使用Protobuf")]),t._v(" "),e("h2",{attrs:{id:"_1、-概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、-概述"}},[t._v("#")]),t._v(" 1、 概述")]),t._v(" "),e("p",[t._v("Protocol buffers 是语言中立、平台中立、可扩展的结构化数据序列化机制，就像 XML，但是它更小、更快、更简单。你只需定义一次数据的结构化方式，然后就可以使用特殊生成的源代码轻松地将结构化数据写入和读取各种数据流，支持各种语言。因为profobuf是二进制数据格式，需要编码和解码。数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。")]),t._v(" "),e("h2",{attrs:{id:"_2、如何使用protobuf呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、如何使用protobuf呢"}},[t._v("#")]),t._v(" 2、如何使用protobuf呢？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("定义了一种源文件，扩展名为 .proto，使用这种源文件，可以定义存储类的内容(消息类型)")])]),t._v(" "),e("li",[e("p",[t._v("protobuf有自己的编译器 protoc，可以将 .proto 编译成对应语言的文件，就可以进行使用了，对于Go，编译器为文件中每种消息类型生成一个.pb.go文件。")])])]),t._v(" "),e("h2",{attrs:{id:"_3、protobuf-hello-world-示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、protobuf-hello-world-示例"}},[t._v("#")]),t._v(' 3、protobuf "hello world" 示例')]),t._v(" "),e("p",[t._v("假设，我们现在需要传输用户信息，其中有username和age两个字段，创建文件user.proto，文件内容如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// 指定的当前proto语法的版本，有2和3\nsyntax = "proto3";\n// option go_package = "path;name"; path 表示生成的go文件的存放地址，会自动生成目录\n// name 表示生成的go文件所属的包名\noption go_package="../service";\n// 指定生成出来的文件的package\npackage service;\n \nmessage User {\n  string username = 1;\n  int32 age = 2;\n}\n')])])]),e("p",[t._v("运行protoc命令编译成go中间文件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# 编译user.proto之后输出到service文件夹\nprotoc --go_out=../service user.proto\n")])])]),e("p",[t._v("项目结构：\n")]),e("p",[e("img",{attrs:{src:"/go/go_6/go_6-1.png",alt:""}}),e("br")]),e("p"),t._v(" "),e("p",[t._v("测试：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package main\n \nimport (\n    "Grpc-Protobuf/service"\n    "fmt"\n    "google.golang.org/protobuf/proto"\n)\n \nfunc main() {\n    user := &service.User{\n        Username: "zhangsan",\n        Age:      20,\n    }\n    //转换为protobuf\n    marshal, err := proto.Marshal(user)\n    if err != nil {\n        panic(err)\n    }\n    newUser := &service.User{}\n    err = proto.Unmarshal(marshal, newUser)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(newUser.String())\n}\n')])])]),e("p",[t._v("输出：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('username:"zhangsan" age:20\n')])])]),e("h2",{attrs:{id:"_4、proto文件语法详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、proto文件语法详解"}},[t._v("#")]),t._v(" 4、proto文件语法详解")]),t._v(" "),e("h3",{attrs:{id:"_4-1-版本"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-版本"}},[t._v("#")]),t._v(" 4.1 版本")]),t._v(" "),e("p",[t._v("Protocol Buffers文档的第一个非注释行，为版本声明，不填写的话默认为版本2。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('syntax = "proto3";\n或者\nsyntax = "proto2";\n')])])]),e("p",[t._v("官方建议新项目采用proto3，proto3简化了proto2的开发，提高了开发的效能，但是也带来了版本不兼容的问题。老项目因为兼容性的问题继续使用proto2,并且会长时间的支持proto2。")]),t._v(" "),e("h3",{attrs:{id:"_4-2-包-package"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-包-package"}},[t._v("#")]),t._v(" 4.2 包（package）")]),t._v(" "),e("p",[t._v("可以向.proto文件中添加可选的package，以防止协议消息类型之间的名称冲突，同名的Message可以通过package进行区分。")]),t._v(" "),e("p",[t._v("在没有为特定语言定义option xxx_package的时候，它还可以用来生成特定语言的包名，比如go package、Java package。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("package foo.bar;\nmessage Open { ... }\n")])])]),e("p",[t._v('包说明符对生成代码的影响取决于您选择的语言，在Go中，包用作Go包名称， 除非在.proto文件中显式提供option go_package，由.proto编译生成go文件时，option go_package = "path;name"配置中name设置的包名会覆盖packag设置的包名。')]),t._v(" "),e("h3",{attrs:{id:"_4-3-选项-option"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-选项-option"}},[t._v("#")]),t._v(" 4.3 选项（option）")]),t._v(" "),e("p",[t._v("go_package（文件选项）：用于生成的Go包。如果在.proto文件中没有给出显式的go_package选项，那么默认情况下将使用proto包（使用.proto文件中的“package”关键字指定）。如果不生成Go代码，则此选项无效。格式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('option go_package = "path;name"; path\n')])])]),e("p",[t._v("path表示生成的go文件的存放地址，会自动生成目录，name 表示生成的go文件所属的包名。如果.proto文件设置了package建议忽略name的配置，如果name也需要配置的话建议设置值和package值一致。")]),t._v(" "),e("h3",{attrs:{id:"_4-4-消息类型-message"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-消息类型-message"}},[t._v("#")]),t._v(" 4.4 消息类型（message）")]),t._v(" "),e("p",[t._v("protobuf中定义一个消息类型是通过关键字message字段指定的，消息就是需要传输的数据格式的定义。message可以包含多种类型字段（field），每个字段声明以分号结尾。message经过protoc编译后会生成对应的class类，field则会生成对应的方法。")]),t._v(" "),e("p",[t._v("message关键字类似于C++中的class，Java中的class，go中的struct")]),t._v(" "),e("p",[t._v("例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message User {\n  string username = 1;\n  int32 age = 2;\n}\n")])])]),e("p",[t._v("在消息中承载的数据分别对应于每一个字段。")]),t._v(" "),e("p",[t._v("其中每个字段都有一个名字和一种类型 。")]),t._v(" "),e("h4",{attrs:{id:"_4-4-1-字段规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-字段规则"}},[t._v("#")]),t._v(" 4.4.1 字段规则")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("required:消息体中必填字段，不设置会导致编解码异常，此关键字可以忽略，例如message user中的username和age字段都是忽略required的必填字段。")])]),t._v(" "),e("li",[e("p",[t._v("optional: 消息体中可选字段。")])]),t._v(" "),e("li",[e("p",[t._v("repeated: 消息体中可重复字段，重复的值的顺序会被保留，在go中重复字段会被定义为切片。")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message User {\n  string username = 1;\n  int32 age = 2;\n  optional string password = 3;  // 生成的是指针\n  repeated string address = 4;   // 生产的是切片\n}\n")])])]),e("h4",{attrs:{id:"_4-4-2-字段映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-字段映射"}},[t._v("#")]),t._v(" 4.4.2 字段映射")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v(".proto Type")]),t._v(" "),e("th",[t._v("Notes")]),t._v(" "),e("th",[t._v("C++ Type")]),t._v(" "),e("th",[t._v("Python Type")]),t._v(" "),e("th",[t._v("Go Type")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("double")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("double")]),t._v(" "),e("td",[t._v("float")]),t._v(" "),e("td",[t._v("float64")])]),t._v(" "),e("tr",[e("td",[t._v("float")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("float")]),t._v(" "),e("td",[t._v("float")]),t._v(" "),e("td",[t._v("float32")])]),t._v(" "),e("tr",[e("td",[t._v("int32")]),t._v(" "),e("td",[t._v("使用变长编码，对于负值的效率很低，如果你的域有 可能有负值，请使用sint64替代")]),t._v(" "),e("td",[t._v("int32")]),t._v(" "),e("td",[t._v("int")]),t._v(" "),e("td",[t._v("int32")])]),t._v(" "),e("tr",[e("td",[t._v("uint32")]),t._v(" "),e("td",[t._v("使用变长编码")]),t._v(" "),e("td",[t._v("uint32")]),t._v(" "),e("td",[t._v("int/long")]),t._v(" "),e("td",[t._v("uint32")])]),t._v(" "),e("tr",[e("td",[t._v("uint64")]),t._v(" "),e("td",[t._v("使用变长编码")]),t._v(" "),e("td",[t._v("uint64")]),t._v(" "),e("td",[t._v("int/long")]),t._v(" "),e("td",[t._v("uint64")])]),t._v(" "),e("tr",[e("td",[t._v("sint32")]),t._v(" "),e("td",[t._v("使用变长编码，这些编码在负值时比int32高效的多")]),t._v(" "),e("td",[t._v("int32")]),t._v(" "),e("td",[t._v("int")]),t._v(" "),e("td",[t._v("int32")])]),t._v(" "),e("tr",[e("td",[t._v("sint64")]),t._v(" "),e("td",[t._v("使用变长编码，有符号的整型值。编码时比通常的 int64高效。")]),t._v(" "),e("td",[t._v("int64")]),t._v(" "),e("td",[t._v("int/long")]),t._v(" "),e("td",[t._v("int64")])]),t._v(" "),e("tr",[e("td",[t._v("fixed32")]),t._v(" "),e("td",[t._v("总是4个字节，如果数值总是比总是比228大的话，这 个类型会比uint32高效。")]),t._v(" "),e("td",[t._v("uint32")]),t._v(" "),e("td",[t._v("int")]),t._v(" "),e("td",[t._v("uint32")])]),t._v(" "),e("tr",[e("td",[t._v("fixed64")]),t._v(" "),e("td",[t._v("总是8个字节，如果数值总是比总是比256大的话，这 个类型会比uint64高效。")]),t._v(" "),e("td",[t._v("uint64")]),t._v(" "),e("td",[t._v("int/long")]),t._v(" "),e("td",[t._v("uint64")])]),t._v(" "),e("tr",[e("td",[t._v("sfixed32")]),t._v(" "),e("td",[t._v("总是4个字节")]),t._v(" "),e("td",[t._v("int32")]),t._v(" "),e("td",[t._v("int\tint32")]),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[t._v("sfixed32")]),t._v(" "),e("td",[t._v("总是4个字节")]),t._v(" "),e("td",[t._v("int32")]),t._v(" "),e("td",[t._v("int")]),t._v(" "),e("td",[t._v("int32")])]),t._v(" "),e("tr",[e("td",[t._v("sfixed64")]),t._v(" "),e("td",[t._v("总是8个字节")]),t._v(" "),e("td",[t._v("int64")]),t._v(" "),e("td",[t._v("int/long")]),t._v(" "),e("td",[t._v("int64")])]),t._v(" "),e("tr",[e("td",[t._v("bool")]),t._v(" "),e("td",[t._v("bool")]),t._v(" "),e("td",[t._v("bool")]),t._v(" "),e("td",[t._v("bool")]),t._v(" "),e("td")]),t._v(" "),e("tr",[e("td",[t._v("string")]),t._v(" "),e("td",[t._v("一个字符串必须是UTF-8编码或者7-bit ASCII编码的文 本。")]),t._v(" "),e("td",[t._v("string")]),t._v(" "),e("td",[t._v("str/unicode")]),t._v(" "),e("td",[t._v("string")])]),t._v(" "),e("tr",[e("td",[t._v("bytes")]),t._v(" "),e("td",[t._v("可能包含任意顺序的字节数据。")]),t._v(" "),e("td",[t._v("string")]),t._v(" "),e("td",[t._v("str")]),t._v(" "),e("td",[t._v("[]byte")])])])]),t._v(" "),e("h4",{attrs:{id:"_4-4-3-字段默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-3-字段默认值"}},[t._v("#")]),t._v(" 4.4.3 字段默认值")]),t._v(" "),e("p",[t._v("protobuf3 删除了 protobuf2 中用来设置默认值的 default 关键字，取而代之的是protobuf3为各类型定义的默认值，也就是约定的默认值，如下表所示：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("类型")]),t._v(" "),e("th",[t._v("默认值")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("bool")]),t._v(" "),e("td",[t._v("false")])]),t._v(" "),e("tr",[e("td",[t._v("整型")]),t._v(" "),e("td",[t._v("0")])]),t._v(" "),e("tr",[e("td",[t._v("string")]),t._v(" "),e("td",[t._v('空字符串""')])]),t._v(" "),e("tr",[e("td",[t._v("枚举enum")]),t._v(" "),e("td",[t._v("第一个枚举元素的值，因为Protobuf3强制要求第一个枚举元素的值必须是0，所以枚举的默认值就是0；")])]),t._v(" "),e("tr",[e("td",[t._v("message")]),t._v(" "),e("td",[t._v("不是null，而是DEFAULT_INSTANCE")])])])]),t._v(" "),e("h4",{attrs:{id:"_4-4-5-标识符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-5-标识符"}},[t._v("#")]),t._v(" 4.4.5 标识符")]),t._v(" "),e("p",[t._v("在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是[0,2^29-1]范围内的一个整数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message Person {\n \n  string name = 1;  // (位置1)\n  int32 id = 2; \n  optional string email = 3; \n  repeated string phones = 4; // (位置4)\n}\n")])])]),e("p",[t._v("以Person为例，name=1，id=2, email=3, phones=4 中的1-4就是标识号。")]),t._v(" "),e("p",[t._v("[1-15]内的标识号在编码时只占用一个字节，包含标识符和字段类型，[16-2047]之间的标识符占用2个字节。建议为频繁出现的字段使用[1-15]间的标识符。")]),t._v(" "),e("h4",{attrs:{id:"_4-4-6-定义多个消息类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-6-定义多个消息类型"}},[t._v("#")]),t._v(" 4.4.6 定义多个消息类型")]),t._v(" "),e("p",[t._v("一个proto文件中可以定义多个消息类型")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message UserRequest {\n  string username = 1;\n  int32 age = 2;\n  optional string password = 3;\n  repeated string address = 4;\n}\n \nmessage UserResponse {\n  string username = 1;\n  int32 age = 2;\n  optional string password = 3;\n  repeated string address = 4;\n}\n")])])]),e("h4",{attrs:{id:"_4-4-7-嵌套消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-7-嵌套消息"}},[t._v("#")]),t._v(" 4.4.7 嵌套消息")]),t._v(" "),e("p",[t._v("可以在其他消息类型中定义、使用消息类型，在下面的例子中，Person消息就定义在PersonInfo消息内，如 ：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message PersonInfo {\n    message Person {\n        string name = 1;\n        int32 height = 2;\n        repeated int32 weight = 3;\n    }\n    repeated Person info = 1;\n}\n")])])]),e("p",[t._v("如果你想在它的父消息类型的外部重用这个消息类型，你需要以PersonInfo.Person的形式使用它，如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message PersonMessage {\n    PersonInfo.Person info = 1;\n}\n")])])]),e("p",[t._v("当然，你也可以将消息嵌套任意多层，如 :")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message Grandpa { // Level 0\n    message Father { // Level 1\n        message son { // Level 2\n            string name = 1;\n            int32 age = 2;\n        }\n    }\n    message Uncle { // Level 1\n        message Son { // Level 2\n            string name = 1;\n            int32 age = 2;\n        }\n    }\n}\n")])])]),e("h4",{attrs:{id:"_4-4-8-注释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-8-注释"}},[t._v("#")]),t._v(" 4.4.8 注释")]),t._v(" "),e("p",[t._v(".proto文件的注释和golang语法一样，//用作单行注释，/"),e("em",[t._v("...")]),t._v("/用作多行注释。")]),t._v(" "),e("h3",{attrs:{id:"_4-5-定义服务-service"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-定义服务-service"}},[t._v("#")]),t._v(" 4.5 定义服务(Service)")]),t._v(" "),e("p",[t._v("如果要在RPC（Remote Procedure Call，远程过程调用）系统中使用消息类型，可以在.proto文件中定义RPC服务接口，协议缓冲区编译器将根据所选语言生成服务接口代码和存根。因此，例如，如果您想用一个方法定义一个RPC服务，该方法接受您的SearchRequest并返回一个SearchResponse，您可以在.proto文件中这样定义它：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("service SearchService {\n    //rpc 服务的函数名 （传入参数）返回（返回参数）\n    rpc Search (SearchRequest) returns (SearchResponse);\n}\n")])])]),e("p",[t._v("上述代表表示，定义了一个RPC服务，该方法接收SearchRequest返回SearchResponse。")]),t._v(" "),e("p",[t._v("与协议缓冲区一起使用的最直接的RPC系统是gRPC：Google开发的一个与语言和平台无关的开源RPC系统。gRPC与协议缓冲区配合得特别好，允许您使用特殊的协议缓冲区编译器插件直接从.proto文件生成相关的RPC代码。")]),t._v(" "),e("h3",{attrs:{id:"_4-6-使用其他消息类型-import"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-使用其他消息类型-import"}},[t._v("#")]),t._v(" 4.6 使用其他消息类型（import）")]),t._v(" "),e("p",[t._v("可以将其他消息类型用作字段类型。例如，假设您希望在每个SearchResponse消息中包含Result消息——为此，您可以在同一.proto中定义Result消息类型，然后在SearchResponse中指定类型为Result的字段：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("message SearchResponse {\n  repeated Result results = 1;\n}\n \nmessage Result {\n  string url = 1;\n  string title = 2;\n  repeated string snippets = 3;\n}\n")])])]),e("p",[t._v("在上面的示例中，Result消息类型与SearchResponse在同一个文件中定义——如果要用作字段类型的消息类型已经在另一个.proto文件中定义了呢？\n通过导入其他.proto文件，可以使用这些文件中的定义。要导入另一个.proto的定义，请在文件顶部添加一个import语句：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('import "myproject/other_protos.proto";\n')])])]),e("p",[t._v("默认情况下，只能使用直接导入的.proto文件中的定义。但是，有时可能需要将.proto文件移动到新位置。不用直接移动.proto文件并在一次更改中更新所有import调用，现在可以在旧位置放置一个伪.proto文件，使用import public概念将所有导入转发到新位置。任何导入包含import public语句的proto的文件都可以传递依赖关系。例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('// new.proto\n// All definitions are moved here　　\n// old.proto\n// This is the proto that all clients are importing.\nimport public "new.proto";\nimport "other.proto";\n\n// client.proto\nimport "old.proto";\n// You use definitions from old.proto and new.proto, but not other.proto\n')])])]),e("p",[t._v("重要：协议编译器使用-I/--proto_path路径标志在协议编译器命令行上指定的一组目录中搜索导入的文件。如果没有给定标志，它将在调用编译器的目录中查找。通常，您应该将--proto_path标志设置为项目的根目录，并对所有导入使用完全限定名。")]),t._v(" "),e("h3",{attrs:{id:"_4-7-生成类-proto-pb-go"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-生成类-proto-pb-go"}},[t._v("#")]),t._v(" 4.7 生成类（.proto->.pb.go）")]),t._v(" "),e("p",[t._v("要生成Go代码，需要使用.proto文件中定义的消息类型和服务，还需要在.proto上运行协议缓冲区编译器protoc。编译器和protobuf的golang插件安装请参见：Mac下安装配置Protocol Buffers")]),t._v(" "),e("p",[t._v("协议编译器的调用方式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("protoc --proto_path=IMPORT_PATH  --go_out=DST_DIR path/to/file.proto\n")])])]),e("ul",[e("li",[e("p",[t._v("IMPORT_PATH：指定解析import指令时要在其中查找.proto文件的目录。如果省略，则使用当前目录。通过多次传递-proto_path选项可以指定多个导入目录；它们将按顺序进行搜索。-I=_IMPORT_PATH_可以用作* --proto_path的缩写形式。")])]),t._v(" "),e("li",[e("p",[t._v("--go_out表示在DST_DIR中生成Go代码。")])]),t._v(" "),e("li",[e("p",[t._v("必须提供一个或多个.proto文件作为输入。可以一次指定多个.proto文件。尽管这些文件是相对于当前目录命名的，但每个文件都必须驻留在IMPORT_PATH导入的其中一个路径中，以便编译器可以确定其规范名称。")])])]),t._v(" "),e("p",[t._v("示例：")]),t._v(" "),e("p",[t._v("编译simple.proto，生成simple.pb.go")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('syntax = "proto3";\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n')])])]),e("p",[t._v("在当前的目录下执行protoc -I=. -I/usr/local/include -I=$(GOPATH)/pkg --go_out=. simple.proto, 可以将这个proto编译成Go的代码，因为这里我们使用了go_out输出格式。")]),t._v(" "),e("p",[t._v("-I指定protoc的搜索import的proto的文件夹。在MacOS操作系统中protobuf把一些扩展的proto放在了/usr/local/include对应的文件夹中（路径根据本地电脑实际存放目录配置，例如/usr/local/protobuf/include），一些第三方的Go库放在了gopath对应的包下，所以这里都把它们加上了。对于这个简单的例子，实际是不需要的。")])])}),[],!1,null,null,null);e.default=s.exports}}]);