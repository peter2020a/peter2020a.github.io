(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{282:function(t,a,n){"use strict";n.r(a);var e=n(13),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1、java实现简单区块链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、java实现简单区块链"}},[t._v("#")]),t._v(" 1、Java实现简单区块链")]),t._v(" "),a("p",[t._v("区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。所谓共识机制是区块链系统中实现不同节点之间建立信任、获取权益的数学算法 。")]),t._v(" "),a("h2",{attrs:{id:"本章目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本章目标"}},[t._v("#")]),t._v(" 本章目标")]),t._v(" "),a("ul",[a("li",[t._v("创建你第一个非常基本的区块链")]),t._v(" "),a("li",[t._v("实现一个简单的工作量证明系统即挖矿")])]),t._v(" "),a("h2",{attrs:{id:"创建区块链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建区块链"}},[t._v("#")]),t._v(" 创建区块链")]),t._v(" "),a("p",[t._v("区块链就是一串或者是一系列区块的集合，类似于链表的概念，每个区块都指向于后面一个区块，然后顺序的连接在一起。那么每个区块中的内容是什么呢？在区块链中的每一个区块都存放了很多很有价值的信息，主要包括三个部分：自己的数字签名，上一个区块的数字签名，还有一切需要加密的数据（这些数据在比特币中就相当于是交易的信息，它是加密货币的本质）。每个数字签名不但证明了自己是特有的一个区块，而且指向了前一个区块的来源，让所有的区块在链条中可以串起来，而数据就是一些特定的信息，你可以按照业务逻辑来保存业务数据。\n")]),a("p",[a("img",{attrs:{src:"/BlockChain/block_1/block_1-1.png",alt:""}}),a("br")]),t._v("\n这里的hash指的就是数字签名"),a("p"),t._v(" "),a("p",[t._v("所以每一个区块不仅包含前一个区块的hash值，同时包含自身的一个hash值，自身的hash值是通过之前的hash值和数据data通过hash计算出来的。如果前一个区块的数据一旦被篡改了，那么前一个区块的hash值也会同样发生变化（因为数据也被计算在内），这样也就导致了所有后续的区块中的hash值。所以计算和比对hash值会让我们检查到当前的区块链是否是有效的，也就避免了数据被恶意篡改的可能性，因为篡改数据就会改变hash值并破坏整个区块链。")]),t._v(" "),a("h2",{attrs:{id:"定义区块链的类快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义区块链的类快"}},[t._v("#")]),t._v(" 定义区块链的类快")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import java.util.Date;\n\npublic class Block {\n\n\tpublic String hash;\n\tpublic String previousHash;\n\tprivate String data; //our data will be a simple message.\n\tprivate long timeStamp; //as number of milliseconds since 1/1/1970.\n\n\t//Block Constructor.\n\tpublic Block(String data,String previousHash ) {\n\t\tthis.data = data;\n\t\tthis.previousHash = previousHash;\n\t\tthis.timeStamp = new Date().getTime();\n\t}\n}\n")])])]),a("p",[t._v("正如你可以看到我们的基本块包含String hash，它将保存我们的数字签名。变量previoushash保存前一个块的hash和String data来保存我们的块数据")]),t._v(" "),a("h2",{attrs:{id:"创建数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建数字签名"}},[t._v("#")]),t._v(" 创建数字签名")]),t._v(" "),a("p",[t._v("熟悉加密算法的朋友们，Java方式可以实现的加密方式有很多，例如BASE、MD、RSA、SHA等等，我在这里选用了SHA256这种加密方式，SHA（Secure Hash Algorithm）安全散列算法，这种算法的特点是数据的少量更改会在Hash值中产生不可预知的大量更改，hash值用作表示大量数据的固定大小的唯一值，而SHA256算法的hash值大小为256位。之所以选用SHA256是因为它的大小正合适，一方面产生重复hash值的可能性很小，另一方面在区块链实际应用过程中，有可能会产生大量的区块，而使得信息量很大，那么256位的大小就比较恰当了。")]),t._v(" "),a("p",[t._v("下面我创建了一个StringUtil方法来方便调用SHA256算法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.security.MessageDigest;\n\npublic class StringUtil {\n\t//Applies Sha256 to a string and returns the result. \n\tpublic static String applySha256(String input){\t\t\n\t\ttry {\n\t\t\tMessageDigest digest = MessageDigest.getInstance("SHA-256");\t        \n\t\t\t//Applies sha256 to our input, \n\t\t\tbyte[] hash = digest.digest(input.getBytes("UTF-8"));\t        \n\t\t\tStringBuffer hexString = new StringBuffer(); // This will contain hash as hexidecimal\n\t\t\tfor (int i = 0; i < hash.length; i++) {\n\t\t\t\tString hex = Integer.toHexString(0xff & hash[i]);\n\t\t\t\tif(hex.length() == 1) hexString.append(\'0\');\n\t\t\t\thexString.append(hex);\n\t\t\t}\n\t\t\treturn hexString.toString();\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\t\n}\n')])])]),a("p",[t._v("或许你完全不理解上述代码的含义，但是你只要理解所有的输入调用此方法后均会生成一个独一无二的hash值（数字签名），而这个hash值在区块链中是非常重要的。")]),t._v(" "),a("p",[t._v("接下来让我们在Block类中应用 方法 applySha256 方法，其主要的目的就是计算hash值，我们计算的hash值应该包括区块中所有我们不希望被恶意篡改的数据，在我们上面所列的Block类中就一定包括previousHash，data和timeStamp，")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public String calculateHash() {\n\tString calculatedhash = StringUtil.applySha256( \n\t\t\tpreviousHash +\n\t\t\tLong.toString(timeStamp) +\n\t\t\tdata \n\t\t\t);\n\treturn calculatedhash;\n}\n")])])]),a("p",[t._v("然后把这个方法加入到Block的构造函数中去")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public Block(String data,String previousHash ) {\n    this.data = data;\n    this.previousHash = previousHash;\n    this.timeStamp = new Date().getTime();\n    this.hash = calculateHash(); //Making sure we do this after we set the other values.\n}\n")])])]),a("h2",{attrs:{id:"测试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[t._v("#")]),t._v(" 测试")]),t._v(" "),a("p",[t._v("在主方法中让我们创建一些区块，并把其hash值打印出来，来看看是否一切都在我们的掌控中。\n第一个块称为创世纪区块，因为它是头区块，所以我们只需输入“0”作为前一个块的previous hash。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('public class NoobChain {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tBlock genesisBlock = new Block("Hi im the first block", "0");\n\t\tSystem.out.println("Hash for block 1 : " + genesisBlock.hash);\n\t\t\n\t\tBlock secondBlock = new Block("Yo im the second block",genesisBlock.hash);\n\t\tSystem.out.println("Hash for block 2 : " + secondBlock.hash);\n\t\t\n\t\tBlock thirdBlock = new Block("Hey im the third block",secondBlock.hash);\n\t\tSystem.out.println("Hash for block 3 : " + thirdBlock.hash);\n\t\t\n\t}\n}\n')])])]),a("p",[t._v("打印：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Hash for block 1: f6d1bc5f7b0016eab53ec022db9a5d9e1873ee78513b1c666696e66777fe55fb\nHash for block 2: 6936612b3380660840f22ee6cb8b72ffc01dbca5369f305b92018321d883f4a3\nHash for block 3: f3e58f74b5adbd59a7a1fc68c97055d42e94d33f6c322d87b29ab20d3c959b8f\n")])])]),a("p",[t._v("每一个区块都必须要有自己的数据签名即hash值，这个hash值依赖于自身的信息（data）和上一个区块的数字签名（previousHash），但这个还不是区块链，下面让我们存储区块到数组中，这里我会引入gson包，目的是可以用json方式查看整个一条区块链结构。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.util.ArrayList;\nimport com.google.gson.GsonBuilder;\n\npublic class NoobChain {\n\t\n\tpublic static ArrayList<Block> blockchain = new ArrayList<Block>(); \n\n\tpublic static void main(String[] args) {\t\n\t\t//add our blocks to the blockchain ArrayList:\n\t\tblockchain.add(new Block("Hi im the first block", "0"));\t\t\n\t\tblockchain.add(new Block("Yo im the second block",blockchain.get(blockchain.size()-1).hash)); \n\t\tblockchain.add(new Block("Hey im the third block",blockchain.get(blockchain.size()-1).hash));\n\t\t\n\t\tString blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);\t\t\n\t\tSystem.out.println(blockchainJson);\n\t}\n\n}\n')])])]),a("p",[t._v("这样的输出结构就更类似于我们所期待的区块链的样子。")]),t._v(" "),a("h2",{attrs:{id:"检查区块链的完整性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查区块链的完整性"}},[t._v("#")]),t._v(" 检查区块链的完整性")]),t._v(" "),a("p",[t._v("在主方法中增加一个isChainValid()方法，目的是循环区块链中的所有区块并且比较hash值，这个方法用来检查hash值是否是于计算出来的hash值相等，同时previousHash值是否和前一个区块的hash值相等。或许你会产生如下的疑问，我们就在一个主函数中创建区块链中的区块，所以不存在被修改的可能性，但是你要注意的是，区块链中的一个核心概念就是去中心化，每一个区块可能是在网络中的某一个节点中产生的，所以很有可能某个节点把自己节点中的数据修改了，那么根据上述的理论数据改变会导致整个区块链的破裂，也就是区块链就无效了。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('public static Boolean isChainValid() {\n\tBlock currentBlock; \n\tBlock previousBlock;\n\t\n\t//loop through blockchain to check hashes:\n\tfor(int i=1; i < blockchain.size(); i++) {\n\t\tcurrentBlock = blockchain.get(i);\n\t\tpreviousBlock = blockchain.get(i-1);\n\t\t//compare registered hash and calculated hash:\n\t\tif(!currentBlock.hash.equals(currentBlock.calculateHash()) ){\n\t\t\tSystem.out.println("Current Hashes not equal");\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\t//compare previous hash and registered previous hash\n\t\tif(!previousBlock.hash.equals(currentBlock.previousHash) ) {\n\t\t\tSystem.out.println("Previous Hashes not equal");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n')])])]),a("p",[t._v("任何区块链中区块的一丝一毫改变都会导致这个函数返回false，也就证明了区块链无效了。")]),t._v(" "),a("p",[t._v("在比特币网络中所有的网络节点都分享了它们各自的区块链，然而最长的有效区块链是被全网所统一承认的，如果有人恶意来篡改之前的数据，然后创建一条更长的区块链并全网发布呈现在网络中，我们该怎么办呢？这就涉及到了区块链中另外一个重要的概念工作量证明，这里就不得不提及一下hashcash，这个概念最早来自于Adam Back的一篇论文，主要应用于邮件过滤和比特币中防止双重支付。")]),t._v(" "),a("h2",{attrs:{id:"挖矿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挖矿"}},[t._v("#")]),t._v(" 挖矿")]),t._v(" "),a("p",[t._v("这里我们要求挖矿者做工作量证明，具体的方式是在区块中尝试不同的参数值直到它的hash值是从一系列的0开始的。让我们添加一个名为nonce的int类型以包含在我们的calculatehash（）方法中，以及需要的mineblock（）方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import java.util.Date;\n\npublic class Block {\n\t\n\tpublic String hash;\n\tpublic String previousHash; \n\tprivate String data; //our data will be a simple message.\n\tprivate long timeStamp; //as number of milliseconds since 1/1/1970.\n\tprivate int nonce;\n\t\n\t//Block Constructor.  \n\tpublic Block(String data,String previousHash ) {\n\t\tthis.data = data;\n\t\tthis.previousHash = previousHash;\n\t\tthis.timeStamp = new Date().getTime();\n\t\t\n\t\tthis.hash = calculateHash(); //Making sure we do this after we set the other values.\n\t}\n\t\n\t//Calculate new hash based on blocks contents\n\tpublic String calculateHash() {\n\t\tString calculatedhash = StringUtil.applySha256( \n\t\t\t\tpreviousHash +\n\t\t\t\tLong.toString(timeStamp) +\n\t\t\t\tInteger.toString(nonce) + \n\t\t\t\tdata \n\t\t\t\t);\n\t\treturn calculatedhash;\n\t}\n\t\n\tpublic void mineBlock(int difficulty) {\n\t\tString target = new String(new char[difficulty]).replace('\\0', '0'); //Create a string with difficulty * \"0\" \n\t\twhile(!hash.substring( 0, difficulty).equals(target)) {\n\t\t\tnonce ++;\n\t\t\thash = calculateHash();\n\t\t}\n\t\tSystem.out.println(\"Block Mined!!! : \" + hash);\n\t}\n}\n")])])]),a("p",[t._v("mineBlock()方法中引入了一个int值称为difficulty难度，低的难度比如1和2，普通的电脑基本都可以马上计算出来，我的建议是在4-6之间进行测试，普通电脑大概会花费3秒时间，在莱特币中难度大概围绕在442592左右，而在比特币中每一次挖矿都要求大概在10分钟左右，当然根据所有网络中的计算能力，难度也会不断的进行修改。")]),t._v(" "),a("p",[t._v("我们在NoobChain类 中增加difficulty这个静态变量。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static int difficulty = 5;\n")])])]),a("p",[t._v("这样我们必须修改主方法中让创建每个新区块时必须触发mineBlock()方法，而isChainValid()方法用来检查每个区块的hash值是否正确，整个区块链是否是有效的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.util.ArrayList;\nimport com.google.gson.GsonBuilder;\n\npublic class NoobChain {\n\t\n\tpublic static ArrayList<Block> blockchain = new ArrayList<Block>();\n\tpublic static int difficulty = 5;\n\n\tpublic static void main(String[] args) {\t\n\t\t//add our blocks to the blockchain ArrayList:\n\t\t\n\t\tblockchain.add(new Block("Hi im the first block", "0"));\n\t\tSystem.out.println("Trying to Mine block 1... ");\n\t\tblockchain.get(0).mineBlock(difficulty);\n\t\t\n\t\tblockchain.add(new Block("Yo im the second block",blockchain.get(blockchain.size()-1).hash));\n\t\tSystem.out.println("Trying to Mine block 2... ");\n\t\tblockchain.get(1).mineBlock(difficulty);\n\t\t\n\t\tblockchain.add(new Block("Hey im the third block",blockchain.get(blockchain.size()-1).hash));\n\t\tSystem.out.println("Trying to Mine block 3... ");\n\t\tblockchain.get(2).mineBlock(difficulty);\t\n\t\t\n\t\tSystem.out.println("\\nBlockchain is Valid: " + isChainValid());\n\t\t\n\t\tString blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);\n\t\tSystem.out.println("\\nThe block chain: ");\n\t\tSystem.out.println(blockchainJson);\n\t}\n\t\n\tpublic static Boolean isChainValid() {\n\t\tBlock currentBlock; \n\t\tBlock previousBlock;\n\t\tString hashTarget = new String(new char[difficulty]).replace(\'\\0\', \'0\');\n\t\t\n\t\t//loop through blockchain to check hashes:\n\t\tfor(int i=1; i < blockchain.size(); i++) {\n\t\t\tcurrentBlock = blockchain.get(i);\n\t\t\tpreviousBlock = blockchain.get(i-1);\n\t\t\t//compare registered hash and calculated hash:\n\t\t\tif(!currentBlock.hash.equals(currentBlock.calculateHash()) ){\n\t\t\t\tSystem.out.println("Current Hashes not equal");\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//compare previous hash and registered previous hash\n\t\t\tif(!previousBlock.hash.equals(currentBlock.previousHash) ) {\n\t\t\t\tSystem.out.println("Previous Hashes not equal");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//check if hash is solved\n\t\t\tif(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) {\n\t\t\t\tSystem.out.println("This block hasn\'t been mined");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n')])])]),a("h2",{attrs:{id:"打印"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打印"}},[t._v("#")]),t._v(" 打印：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('Connected to the target VM, address: \'127.0.0.1:61863\', transport: \'socket\'\nTrying to Mine block 1... \nBlock Mined!!! : 0000016667d4240e9c30f53015310b0ec6ce99032d7e1d66d670afc509cab082\nTrying to Mine block 2... \nBlock Mined!!! : 000002ea55735bea4cac7e358c7b0d8d81e8ca24021f5f85211bf54fd4ac795a\nTrying to Mine block 3... \nBlock Mined!!! : 000000576987e5e9afbdf19b512b2b7d0c56db0e6ca49b3a7e638177f617994b\n\nBlockchain is Valid: true\n[\n  {\n    "hash": "0000016667d4240e9c30f53015310b0ec6ce99032d7e1d66d670afc509cab082",\n    "previousHash": "0",\n    "data": "first",\n    "timeStamp": 1520659506042,\n    "nonce": 618139\n  },\n  {\n    "hash": "000002ea55735bea4cac7e358c7b0d8d81e8ca24021f5f85211bf54fd4ac795a",\n    "previousHash": "0000016667d4240e9c30f53015310b0ec6ce99032d7e1d66d670afc509cab082",\n    "data": "second",\n    "timeStamp": 1520659508825,\n    "nonce": 1819877\n  },\n  {\n    "hash": "000000576987e5e9afbdf19b512b2b7d0c56db0e6ca49b3a7e638177f617994b",\n    "previousHash": "000002ea55735bea4cac7e358c7b0d8d81e8ca24021f5f85211bf54fd4ac795a",\n    "data": "third",\n    "timeStamp": 1520659515910,\n    "nonce": 1404341\n  }\n]\n')])])]),a("p",[t._v("经过测试增加一个新的区块即挖矿必须花费一定时间，大概是3秒左右，你可以提高difficulty难度来看，它是如何影响数据难题所花费的时间的")]),t._v(" "),a("p",[t._v("如果有人在你的区块链系统中恶意篡改数据：")]),t._v(" "),a("p",[t._v("他们的区块链是无效的。\n他们无法创建更长的区块链\n网络中诚实的区块链会在长链中更有时间的优势\n因为篡改的区块链将无法赶上长链和有效链，除非他们比你网络中所有的节点拥有更大的计算速度，可能是未来的量子计算机或者是其他什么。")]),t._v(" "),a("p",[t._v("你的区块链：")]),t._v(" "),a("ul",[a("li",[t._v("有很多区块组成用来存储数据")]),t._v(" "),a("li",[t._v("有数字签名让你的区块链链接在一起")]),t._v(" "),a("li",[t._v("需要挖矿的工作量证明新的区块")]),t._v(" "),a("li",[t._v("可以用来检查数据是否是有效的同时是未经篡改的")])])])}),[],!1,null,null,null);a.default=s.exports}}]);