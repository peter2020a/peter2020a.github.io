(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{295:function(t,a,r){"use strict";r.r(a);var o=r(13),e=Object(o.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"protobuf尝鲜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#protobuf尝鲜"}},[t._v("#")]),t._v(" Protobuf尝鲜")]),t._v(" "),a("p",[t._v("  最近公司项目需要使用protobuf，所以研究了下protobuf对比json的优势。")]),t._v(" "),a("h2",{attrs:{id:"_1-什么是-protobuf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是-protobuf"}},[t._v("#")]),t._v(" 1 什么是 Protobuf")]),t._v(" "),a("p",[t._v("  Protobuf 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的数据载体，很适合做数据存储或 RPC 数据交换格式，它序列化出来的数据量少再加上以 K-V 的方式来存储数据，对消息的版本兼容性非常强，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。")]),t._v(" "),a("h3",{attrs:{id:"_1-1-protobuf-消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-protobuf-消息"}},[t._v("#")]),t._v(" 1.1 Protobuf 消息")]),t._v(" "),a("p",[t._v("  message 由至少一个字段组合而成，类似于 C 语言中的结构。每个字段都有一定的格式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("限定修饰符 | 数据类型 | 字段名称 | = | 字段编码值 | [字段默认值]\n")])])]),a("h3",{attrs:{id:"_1-2-限定修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-限定修饰符"}},[t._v("#")]),t._v(" 1.2 限定修饰符")]),t._v(" "),a("ul",[a("li",[t._v("message 就是相当于 class")]),t._v(" "),a("li",[t._v("Required：表示是一个必须字段，必须相对于发送方，在发送消息之前必须设置该字段的值；对于接收方，必须能够识别该字段的意思。发送之前没有设置 required 字段或者无法识别 required 字段都会引发编解码异常，导致消息被丢弃。")]),t._v(" "),a("li",[t._v("Optional：表示是一个可选字段，可选对于发送方，在发送消息时，可以有选择性的设置或者不设置该字段的值；对于接收方，如果能够识别可选字段就进行相应的处理，如果无法识别，则忽略该字段，消息中的其它字段正常处理。很多接口在升级版本中都把后来添加的字段都统一的设置为 optional 字段，这样老的版本无需升级程序也可以正常的与新的软件进行通信，只不过新的字段无法识别而已，因为并不是每个节点都需要新的功能，因此可以做到按需升级和平滑过渡。")]),t._v(" "),a("li",[t._v("Repeated：表示该字段可以包含 0 ~ N 个元素，可以看作是在传递数组。")])]),t._v(" "),a("h2",{attrs:{id:"_2-protobuf-的优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-protobuf-的优势"}},[t._v("#")]),t._v(" 2 Protobuf 的优势")]),t._v(" "),a("ul",[a("li",[t._v("（1）序列化后体积相比 Json 和 XML 很小，适合网络传输")]),t._v(" "),a("li",[t._v("（2）支持跨平台多语言")]),t._v(" "),a("li",[t._v("（3）消息格式升级和兼容性不错，“向后” 兼容性好")]),t._v(" "),a("li",[t._v("（4）序列化反序列化速度很快，快于 Json 的处理速速")]),t._v(" "),a("li",[t._v("（5）Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。\nProtobuf 与 JSON 的数据大小对比： "),a("br"),t._v("\n（1）Protobuf 的数据大小\n"),a("img",{attrs:{src:"/java/java_2/java_2-1.png",alt:""}}),t._v("\n（1）JSON 的数据大小\n"),a("img",{attrs:{src:"/java/java_2/java_2-2.png",alt:""}})])]),t._v(" "),a("h2",{attrs:{id:"_3-为什么-protobuf-的速度快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-为什么-protobuf-的速度快"}},[t._v("#")]),t._v(" 3 为什么 Protobuf 的速度快")]),t._v(" "),a("p",[t._v("  Protobuf 的主要优点在于性能高。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。\n对于这些 “小 3 到 10 倍”,“快 20 到 100 倍” 的说法，严肃的程序员需要一个解释。因此在本文的最后，让我们稍微深入 Protobuf 的内部实现吧。")]),t._v(" "),a("p",[t._v("有两项技术保证了采用 Protobuf 的程序能获得相对于 XML 极大的性能提高。")]),t._v(" "),a("h3",{attrs:{id:"_3-1-zigzag-编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-zigzag-编码"}},[t._v("#")]),t._v(" 3.1 Zigzag 编码")]),t._v(" "),a("p",[t._v("  第一点，我们可以考察 Protobuf 序列化后的信息内容。您可以看到 Protocol Buffer 信息的表示非常紧凑，这意味着消息的体积减少，自然需要更少的资源。比如网络上传输的字节数更少，需要的 IO 更少等，从而提高性能。这个利益于 Protobuf 采用的非常巧妙的 Encoding 方法：Zigzag 编码。")]),t._v(" "),a("p",[t._v("  介绍 Zigzag 编码前，先普及一下一个叫做 Varint 的术语。")]),t._v(" "),a("p",[t._v("  Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。")]),t._v(" "),a("p",[t._v("  消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 Key-Value 对。下面就详细介绍一下 Varint。")]),t._v(" "),a("p",[t._v("  Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：1010 1100 0000 0010。")]),t._v(" "),a("p",[t._v("  在计算机内，一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 5 个 byte。为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码，用无符号数来表示有符号数字，正数和负数交错，-1 将会被编码成 1，1 将会被编码成 2，-2 会被编码成 3。")]),t._v(" "),a("p",[t._v("  使用 zigzag 编码，绝对值小的数字，无论正负都可以采用较少的 byte 来表示，充分利用了 Varint 这种技术。其他的数据类型，比如字符串等则采用类似数据库中的 varchar 的表示方法，即用一个 varint 表示长度，然后将其余部分紧跟在这个长度部分之后即可。")]),t._v(" "),a("p",[t._v("  比如我们定义如下 protobuf 文件：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("package lm;\nmessage helloworld\n {\n    required int32     id = 1;  // ID\n    required string    str = 2;  // str\n    optional int32     opt = 3;  //optional field\n }\n")])])]),a("p",[t._v("转化为相应的. java 文件后，我们可以发现有这个方法，进行二进制的转存。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public void writeTo(com.google.protobuf.CodedOutputStream output)\n                       throws java.io.IOException {\n     getSerializedSize();\n     if (((bitField0_ & 0x00000001) == 0x00000001)) {\n       output.writeUInt32(1, width_);\n     }\n     if (((bitField0_ & 0x00000002) == 0x00000002)) {\n       output.writeUInt32(2, height_);\n     }\n     getUnknownFields().writeTo(output);\n   }\n")])])]),a("p",[t._v("用 Protobuf 序列化后的字节序列为：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("08 65 12 06 48 65 6C 6C 6F 77\n")])])]),a("p",[t._v("而如果用 XML，则类似这样：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("31 30 31 3C 2F 69 64 3E 3C 6E 61 6D 65 3E 68 65\n6C 6C 6F 3C 2F 6E 61 6D 65 3E 3C 2F 68 65 6C 6C\n6F 77 6F 72 6C 64 3E\n")])])]),a("h3",{attrs:{id:"_3-2-protobuf-解包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-protobuf-解包"}},[t._v("#")]),t._v(" 3.2 Protobuf 解包")]),t._v(" "),a("p",[t._v("  先来了解一下 XML 的封解包过程。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。")]),t._v(" "),a("p",[t._v("  Protobuf 解包，只需要简单地将一个二进制序列，按照指定的格式读取到对应的结构类型中就可以了。消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成，速度非常快。")]),t._v(" "),a("p",[t._v("  Protobuf 压缩优势主要在于对 integer 的压缩，甚至有符号无符号都采用了不同的编码方式，能够提供极高的压缩比。而字符串对象目前据我所知是没有编码的，不过可以对 pb 再次进行压缩；")])])}),[],!1,null,null,null);a.default=e.exports}}]);