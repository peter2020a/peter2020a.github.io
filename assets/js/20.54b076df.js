(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{291:function(a,t,n){"use strict";n.r(t);var e=n(13),s=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"go-的基本命令详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#go-的基本命令详解"}},[a._v("#")]),a._v(" go 的基本命令详解")]),a._v(" "),t("p",[a._v("go 的基本命令")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("go 命令的基本用法是：go command [arguments]\ngo 的基本命令有：build, clean, env, fix, fmt, generate, get, install, list, run, test, tool, version, vet\n")])])]),t("h2",{attrs:{id:"_1-build-flags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-build-flags"}},[a._v("#")]),a._v(" 1 build flags")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("以下构建标志由build, clean, get, install, list, run, test 命令共有：\n-a：强制重建已经是最新的软件包，在 Go 版本中，不适用于标准库；\n-n：打印编译期间所用到的命令，但是并不真正执行它们;\n-pn：可以并行运行的构建数量，在默认情况下，该数量等于CPU的逻辑核数；\n-race：启用数据竞争检测，仅支持 linux/amd64、freebsd/amd64、darwin/amd64 和 windows/amd64；\n-v：在编译时打印包的名称；\n-work：打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录；\n-x：打印编译期间所用到的其它命令;\n-ccflags：‘参数列表’，传递给每个 5c、6c 或 8c 编译器调用的参数；\n-compiler name：要使用的编译器名称，如runtime.Compiler（gccgo 或gc）；\n-gccgoflags ‘arg list’：传递给每个 gccgo 编译器/链接器调用的参数；\n-gcflags ‘arg list’：每个 5g、6g 或 8g 编译器调用时传递的参数；\n-installsuffix suffix：在包安装目录的名称中使用的后缀，以便将输出与默认构建分开；如果使用 -race 标志，安装后缀将自动设置为 Race，或者如果明确设置，则附加 _race；\n-ldflags ‘flag list’：传递给每个 5l、6l 或 8l 链接器调用的参数；\n-tags ‘tag list’：在构建过程中要考虑满足的构建标签列表。\n列表标志接受以空格分隔的字符串列表，要在列表元素中嵌入空格，请用单引号或双引号将其括起来。\n")])])]),t("h2",{attrs:{id:"_2-go-build"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-go-build"}},[a._v("#")]),a._v(" 2 go build")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go build [build flags] [packages]\ngo build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包。\n如果我们在执行 go build 命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包。\ngo build 命令既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件，因为此时会包括多个main函数，显示函数重命名错误。\ngo build 本地代码包路径只能以目录相对路径的形式呈现，而不能使用目录绝对路径，即只能用./或…/或是直接当前包开始。\ngo build 构建标志：\n-o name：标记可以指定输出文件的名称；\n-i：安装那些编译目标依赖的且还未被安装的代码包;\n")])])]),t("h2",{attrs:{id:"_3-go-clean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-go-clean"}},[a._v("#")]),a._v(" 3 go clean")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go clean [build flags] [packages]\ngo clean 命令会删除掉执行其它命令时产生的一些文件和目录，go 命令会在临时目录中构建对象，因此 go clean 主要关注其他工具或手动调用 go build 留下的对象文件。\ngo clean 从与导入路径对应的每个源目录中删除以下文件：\n_obj/：Makefile 留下的旧的对象目录；\n_test/：Makefile 留下的旧的测试目录；\n_testmain.go：Makefile 留下的旧的gotest文件；\ntest.out：Makefile 留下的旧的测试日志；\nbuild.out：Makefile 留下的旧的构建日志；\n*.[568ao]：Makefile 留下的旧的对象文件；\nDIR(.exe)：go build 生成的可执行文件，dir为最底层文件夹名；\nDIR.test(.exe)：go test -c 生成的可执行文件；\nMAINFILE(.exe)：go build MAINFILE.go 生成的文件；\n*.so：SWIG生成的文件；\ngo clean 构建标志：\n-i：删除安装当前代码包时所产生的结果文件，即bin或pkg下的文件；\n-r：标以递归方式应用于由导入路径命名的包的所有依赖项；\n-cache：删除整个 go build 缓存；\n-testcache：使 go build 缓存中的所有测试结果过期；\n-modcache：删除整个模块下载缓存，包括版本化依赖项的解压缩源代码。\n")])])]),t("h2",{attrs:{id:"_4-go-doc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-go-doc"}},[a._v("#")]),a._v(" 4 go doc")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go doc [doc flags] [package|[package.]symbol[.methodOrField]]\ngo doc\ngo doc\ngo doc [.]\ngo doc [.][.]\ngo doc [.][.]\ngo doc 打印与由其参数（包、const、func、类型、var、方法或结构字段）标识的项目相关联的文档注释。\n在所有形式中，当匹配符号时，参数中的小写字母匹配任一大小写，但大写字母完全匹配。这意味着如果不同的符号具有不同的大小写，则包中可能存在多个小写参数的匹配项。如果发生这种情况，则会打印所有匹配项的文档。\ngo doc 文档标志：\n-all：显示所有的包文档；\n-c：匹配时遵循大小写规则；\n-cmd：像对待常规包一样对待命令（包 main），否则当显示包的顶级文档时，包 main 的导出符号被隐藏；\n-short：用一行来显示；\n-src：显示符号的完整源代码，这会显示其声明的完整 Go 源代码和定义，如函数定义、类型声明或封闭 const 堵塞；\n-u：显示未导出和导出的文档符号、方法和字段；\n-src：附加查看源码；\n-ex：附加查看用例；\ncmd/：查看可执行文件go的文档；\n-goroot=“”：定制一个go语言根目录，在该目录下查找代码包文档，仅限于当次命令；\n-http=:6060：查看HTML格式的文档，启动的Web服务器使用本机的6060端口，然后在址栏中输入http://localhost:6060来查看以网页方式展现的Go文档；\n-index：在网页浏览模式下开启索引；\n-q：开启远程查询功能；\ngodoc -q -server=“ip:port” pkg：启动go文档的web服务器后，则可以在远程指定ip和端口查询指定包。\n")])])]),t("h2",{attrs:{id:"_5-go-env"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-go-env"}},[a._v("#")]),a._v(" 5 go env")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go env [flag] [var …]\ngo env 用于打印Go语言的环境信息。\ngo doc 标志：\n-json：标志以 JSON 格式而不是作为 shell 脚本打印环境。\n-u：标志需要一个或多个参数，并取消命名环境变量的默认设置，如果已使用 ‘go env -w’ 设置的话。\n-w：标志需要一个或多个 NAME=VALUE 形式的参数，并将命名环境变量的默认设置更改为给定值。\ngo env 相关打印信息：\nCGO_ENABLED：指明cgo工具是否可用的标识；\nGOARCH：程序构建环境的目标计算架构；\nGOBIN：存放可执行文件的目录的绝对路径；\nGOCHAR：程序构建环境的目标计算架构的单字符标识；\nGOEXE：可执行文件的后缀，非win系统为空；\nGOHOSTARCH：程序运行环境的目标计算架构；\nGOOS：程序构建环境的目标操作系统；\nGOHOSTOS：程序运行环境的目标操作系统；\nGOPATH：工作区目录的绝对路径；\nGORACE：用于数据竞争检测的相关选项；\nGOROOT：Go语言的安装目录的绝对路径；\nGOTOOLDIR：Go工具目录的绝对路径；\n")])])]),t("h2",{attrs:{id:"_6-go-fix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-go-fix"}},[a._v("#")]),a._v(" 6 go fix")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go fix [packages]\ngo fix 命令把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。\ngo fix 其实是 go tool fix 的简单封装，会先对作为参数的代码包导入路径进行验证，以确保它是正确有效的，然后把有效代码包中的所有Go语言源码文件作为多个参数传递给 go tool fix 命令。\ngo fix 命令参数：\n-diff：不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。\n-r：只对目标源码文件做有限的修正操作，该标记的值即为允许的修正操作的名称，多个名称之间用英文半角逗号分隔。\n-force：即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。\n")])])]),t("h2",{attrs:{id:"_7-go-fmt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-go-fmt"}},[a._v("#")]),a._v(" 7 go fmt")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go fmt [-n] [-x] [packages]\ngo fmt file.go：将go程序格式化，自动对齐、空格等。\n")])])]),t("h2",{attrs:{id:"_8-go-generate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-go-generate"}},[a._v("#")]),a._v(" 8 go generate")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go… | packages]\ngo generate ⽣成由现有⽂件中的指令描述的运⾏命令。这些命令可以运⾏任何进程，但⽬的是创建或更新 Go 源文件。\n")])])]),t("h2",{attrs:{id:"_9-go-get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-go-get"}},[a._v("#")]),a._v(" 9 go get")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go get [-d] [-t] [-u] [-v] [build flags] [packages]\ngo get 根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。\ngo get 下载的依赖包一般在 $GOPATH/src下，如果指定了多个 $GOPATH，则在第一个 $GOPATH的src下。\ngo get 命令在检出代码包之前必须要知道代码包远程导入路径所对应的版本控制系统和远程仓库的URL。\ngo get 所支持的代码版本控制系统vcs有：\nhg：Mercurial；\ngit：Git；\nsvn：Subversion；\nbzr：Bazaar；\ngo get 命令包含了build和install操作，所以可以接收两者所有的命令参数，另外其特有的命令参数有：\n-d：让命令只执行下载动作，而不执行安装动作；\n-fix：让命令在下载代码包后先执行修正动作，而后再进行编译和安装。fix 工具可以修复因Go语言规范变更而造成的语法级别的错误；\n-t：开始考虑构建命令⾏上指定的包的测试所需的模块；\n-u：让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包；\n-u=patch：指示 get 更新依赖项，但更改默认值以选择补丁版本。\ngo get 内置了代码包多版本依赖管理功能，在使用它检出或更新代码包之后，它会寻找与本地已安装Go语言的版本号相对应的标签（tag）或分支（branch）。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。\n")])])]),t("h2",{attrs:{id:"_10-go-install"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-go-install"}},[a._v("#")]),a._v(" 10 go install")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go install [build flags] [packages]\ngo install 用于编译并安装指定的代码包及它们的依赖包。\ngo install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到结果文件存放的目录，一般是GOBIN目录，即 $GOPATH/bin。\ngo install 只有在安装命令源文件时，才会在程序内部给代表其结果文件存放目录的变量赋值；在安装库源码文件时该值依然是空值。\n")])])]),t("h2",{attrs:{id:"_11-go-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-go-list"}},[a._v("#")]),a._v(" 11 go list")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go list [-f format] [-json] [-m] [list flags] [build flags] [packages]\ngo list 列出命名的包，每⾏⼀个，需要以代码包导入路径的方式给定代码包。\n标志解析：\n-f：标志使⽤包模板的语法指定列表的替代格式；\n-json：标志使包数据以 JSON 格式打印，⽽不是使⽤模板格式；\n-m：标志导致 list 列出模块⽽不是包；\n-e：以容错模式加载和分析指定的代码包；\n")])])]),t("h2",{attrs:{id:"_12-go-mod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-go-mod"}},[a._v("#")]),a._v(" 12 go mod")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go mod [arguments]\ngo mod 命令：\ndownload：下载模块到本地缓存；\nedit：从工具或脚本编辑go.mod；\ngraph：打印模块需求表；\ninit：在当前目录初始化一个新的模块\ntidy：添加丢失的模块并删除未使用的模块；\nvendor：制作依赖项的副本；\nverify：验证依赖项是否有预期内容；\nwhy：解释模块或包为什么需要；\ngo mod download [-x] [-json] [modules]：下载命名的模块，可以是模块模式选择主模块的依赖关系，也可以是 path@version 形式的模块查询。没有参数时，下载适⽤于主模块的所有依赖项（相当于“go mod download all”）。\n-json ：将⼀系列 JSON 对象打印到标准输出，描述每个下载的模块，对应于这个 Go 结构：\ntype Module struct {\n    Path     string //模块路径\n    Version  string //模块版本\n    Error    string //模块加载错误\n    Info     string //.info缓存文件的绝对路径\n    GoMod    string //.mod缓存文件的绝对路径\n    Zip      string //.zip缓存文件的绝对路径\n    Dir      string //缓存根目录的绝对路径\n    Sum      string //路径、版本的校验和\n    GoModSum string //go.mod 的校验和\n}\n\n-x：打印下载执⾏的命令；\ngo mod edit [editing flags] [-fmt|-print|-json] [go.mod]：提供了⼀个⽤于编辑 go.mod 的命令⾏界⾯，主要供⼯具或脚本使⽤。它只读取 go.mod，不查找有关模块的信息。\n编辑标志指定编辑操作的序列：\n-module：更改模块的路径；\n-require=path@version 和 -droprequire=path：添加或删除给定路径和版本的模块到需求项；\n-exclude=path@version 和 -dropexclude=path@version：添加或删除给定路径和版本的模块到排除项；\n-replace=old[@v]=new[@v]：替换给定路径和版本的模块；\n-dropreplace=old[@v]：丢弃给定模块路径和版本对的替换；\n-go=version：设置预期的 Go 语⾔版本；\n-fmt ：重新格式化 go.mod ⽂件⽽不进⾏其他更改；\n-print 标志以其⽂本格式打印最终的 go.mod；\n-json 标志以 JSON 格式打印最终的 go.mod ⽂件；\ngo mod graph [-go=version]：以文本形式打印模块需求表；\ngo mod init [module-path]：在当前⽬录中初始化并写⼊⼀个新的 go.mod ⽂件，实际上创建了⼀个以当前⽬录为根的新模块。\ngo.mod ⽂件必须不存在；\n接受⼀个可选参数，即新模块的模块路径；\n如果省略了模块路径参数，go init 将尝试使⽤ .go ⽂件、 vendoring ⼯具配置⽂件（如 Gopkg.lock）和当前⽬录（如果在 GOPATH 中）中的导⼊注释来推断模块路径。\ngo mod tidy [-e] [-v] [-go=version] [-compat=version]：它添加构建当前模块的包和依赖项所需的任何缺失模块，并删除不提供任何相关包的未使⽤模块；它还向 go.sum 添加任何缺失的条⽬并删除任何不必要的条⽬。\n-v：将有关已删除模块的信息打印到标准错误；\n-e：遇到错误时继续尝试加载包；\ngo mod vendor [-e] [-v]：供应商重置主模块的供应商⽬录以包含构建和测试所有主模块的包所需的所有包。\n参数同上；\n")])])]),t("h2",{attrs:{id:"_13-go-run"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-go-run"}},[a._v("#")]),a._v(" 13 go run")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go run [build flags] [-exec xprog] package [arguments…]\ngo run 命令可以编译并运行命令源码文件，并把编译后的可执行文件存放到临时工作目录。\ngo run 命令只接受Go源码文件作为参数，而不接受代码包，更不接收测试文件。\ngo run 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此，因为多个命令源码文件都有相同的main函数声明。\n命令源码文件如果可以接受参数，则可以在执行 go run 命令运行这个命令源码文件时把参数名和参数值成对的追加在后面，go run 命令会把参数原封不动的传给对应的可执行文件。\n-exec：将使⽤ xprog 调⽤⼆进制⽂件；\n")])])]),t("h2",{attrs:{id:"_14-go-test"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-go-test"}},[a._v("#")]),a._v(" 14 go test")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go test [build/test flags] [packages] [build/test flags & test binary flags]\ngo test 命令用于以代码包为单位对Go语言编写的程序进行测试。\n测试源码文件是名称以“_test.go”为后缀的，内含若干测试函数的源码文件。测试函数一般是以“Test”为名称前缀并有一个类型为“testing.T”的参数声明的函数。\n一般情况下，我们会把测试源码文件与被测试的源码文件放在同一个代码包中。并且，这些源码文件中声明的包名也都是相同的。\ngo test 以下参数：\n-c：生成用于运行测试的可执行文件，但不执行它；\n-i: 安装/重新安装运行测试所需的依赖包但不编译和运行测试代码；\ngo test 中的以下相关函数可以在测试函数中通过t.fun…方式执行：\nfunc (t *T) Fail()：标记测试函数失败，但仍然继续执行；\nfunc (t *T) FailNow()：标记测试函数失败，并中断其执行，然后执行下一文件中的测试函数；\nfunc (t *T) Log(args… interface{})：用默认格式对其参数进行格式化，与 Print() 类似，并且记录文本到错误日志；\nfunc (t *T) Fatal(args… interface{})：等价于Log()后跟随FailNow()；\n")])])]),t("h2",{attrs:{id:"_15-go-version"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-go-version"}},[a._v("#")]),a._v(" 15 go version")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("go version [-m] [-v] [file …]：打印 Go 可执⾏⽂件的构建信息。\n如果命令⾏上没有指定⽂件，go version 会打印⾃⼰的版本信息。\n-v：报告⽆法识别的⽂件。\n-m：使 go version 在可⽤时打印每个可执⾏⽂件的嵌⼊式模块版本信息。\n")])])]),t("h2",{attrs:{id:"_16-go-vet"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-go-vet"}},[a._v("#")]),a._v(" 16 go vet")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("用法：go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]\ngo vet 用于检查Go语言源码中静态错误的简单工具。\ngo vet 依然支持-n、-x命令参数，另外还有：\n-all：进行全部检查；\n-assign：检查赋值语句；\nprint：检查打印函数是否使用正确；\nmethods：检查标准命名方法的签名；\n……\ngo vet 能够捕获的错误有：\nPrintf 类函数调用时，类型匹配错误的参数；\n定义常用的方法时，方法签名的错误；\n错误的结构标签；\n没有指定字段名的结构字面量；\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);